<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P4.2 Shaders - Albasel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
</head>
<body>
    <nav class="topnav">
    <div class="topnav-inner">
        <a href="/" class="topnav-logo">Albasel</a>
        
        <button class="nav-hamburger" id="nav-hamburger" aria-label="Toggle menu">
            <i class="fas fa-bars"></i>
        </button>

        <ul class="topnav-links" id="nav-links">
            <li><a href="/">Home</a></li>
            <li><a href="/posts.html">Posts</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/aboutme.html">About</a></li>
        </ul>

        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
            <i class="fa-solid fa-moon" id="theme-icon"></i>
        </button>
    </div>
</nav>


    <div class="main-content">
        <article class="article">
            <header class="article-header">
                <h1>P4.2 Shaders</h1>
                <div class="article-meta">
                    
                    <span class="article-category">OpenGL</span>
                    
                    <time>2024-01-01</time>
                </div>
                
                <img src="/images/opengl.jpg" alt="P4.2 Shaders" class="article-image">
                
            </header>

            <div class="post-content">
                <h4>Writing our own Shader</h4>
<p>The plan is to create a function that takes <strong>vertexShader</strong>, <strong>fragmentShader</strong> source codes, compile them and provide a “<strong>program</strong>” that works as a shader for our triangle.</p>
<p>First let’s define a function that compiles shader string <strong>( we will basically write code in a string that opengl can later read it)</strong>.</p>
<pre class="hljs"><code><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">CompileShader</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; source)</span> {
    <span class="hljs-comment">// Create a shader object of the specified type</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id = glCreateShader(type);

    <span class="hljs-comment">// Get a pointer to the C string of the source code</span>
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = source.c_str();

    <span class="hljs-comment">// Provide the shader source code to OpenGL</span>
    glShaderSource(id, <span class="hljs-number">1</span>, &amp;src, nullptr);

    <span class="hljs-comment">// Compile the shader</span>
    glCompileShader(id);

    <span class="hljs-comment">// Check for compilation errors</span>
    <span class="hljs-type">int</span> result;
    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);
    <span class="hljs-keyword">if</span> (result == GL_FALSE) {
        <span class="hljs-comment">// If there&#x27;s an error, retrieve the error message</span>
        <span class="hljs-type">int</span> length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);

        <span class="hljs-comment">// Allocate memory on the stack for the error message</span>
        <span class="hljs-type">char</span>* message = (<span class="hljs-type">char</span>*)alloca(length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));

        <span class="hljs-comment">// Retrieve the error message</span>
        glGetShaderInfoLog(id, length, &amp;length, message);

        <span class="hljs-comment">// Print the error message</span>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Fail to Compile Shader: &quot;</span> &lt;&lt; message &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

        <span class="hljs-comment">// Delete the shader as it&#x27;s not needed anymore</span>
        glDeleteShader(id);

        <span class="hljs-comment">// Return 0 to indicate failure</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Return the ID of the successfully compiled shader</span>
    <span class="hljs-keyword">return</span> id;
}

</code></pre>
<ul>
<li><strong>Create Shader Object:</strong> unsigned int id = glCreateShader(type); creates a shader object of the specified type (<strong>GL_VERTEX_SHADER</strong> or <strong>GL_FRAGMENT_SHADER</strong>).</li>
</ul>
<p><img src="https://i.postimg.cc/fWm1rLS4/image.png" alt=""></p>
<hr>
<ul>
<li><strong>Provide Source Code:</strong> <code>const char* src = source.c_str();</code> gets a pointer to the C string of the shader source code provided as a parameter.</li>
</ul>
<hr>
<ul>
<li><strong>Set Shader Source:</strong> <code>glShaderSource(id, 1, &amp;src, nullptr);</code> provides the shader source code to OpenGL.</li>
</ul>
<p><img src="https://i.postimg.cc/fWm1rLS4/image.png" alt=""></p>
<hr>
<ul>
<li><strong>Compile Shader:</strong> <code>glCompileShader(id); </code>compiles the shader. glCompileShader compiles the source code strings that have been stored in the shader object specified by shader</li>
</ul>
<blockquote>
<p>The compilation status will be stored as part of the shader object’s state. This value will be set to GL_TRUE if the shader was compiled without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling glGetShader with arguments shader and GL_COMPILE_STATUS.</p>
</blockquote>
<p><img src="https://i.postimg.cc/KjWKTNPV/image.png" alt=""></p>
<hr>
<ul>
<li><strong>Check Compilation Status:</strong> <code>(id, GL_COMPILE_STATUS,  &amp;result); </code>checks if the compilation was successful.</li>
</ul>
<p><img src="https://i.postimg.cc/SNrSHVYp/image.png" alt=""></p>
<hr>
<ul>
<li><strong>Handle Compilation Errors:</strong> If there’s an error, the function retrieves and prints the error message using <code>glGetShaderInfoLog</code> and deallocates the shader object. The error message is printed to the console.</li>
</ul>
<p><img src="https://i.postimg.cc/SNrSHVYp/image.png" alt=""></p>
<hr>
<ul>
<li><strong>Return Shader ID:</strong> If the compilation is successful, it returns the ID of the compiled shader for later use.</li>
</ul>
<hr>
<p>The fundamental purpose of the <code>CreateShader</code> function is to perform a couple of tasks, but at its core, we need to supply OpenGL with the code text. Afterward, it links both components together and returns a unique identifier. This identifier allows us to bind the shader and use it, akin to how we generate a buffer that provides us with an ID, which we can then bind to access and utilize.</p>
<p>so the function takes two sources codes, sends them to compile function, then returns <code>Gluint</code> type shader that we can bind and use for our triangle.</p>
<pre class="hljs"><code><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">CreateShader</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; vertexShader, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; fragmentShader)</span> {
    <span class="hljs-comment">// Create a shader program object</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> program = glCreateProgram();

    <span class="hljs-comment">// Compile the vertex and fragment shaders</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

    <span class="hljs-comment">// Attach the compiled shaders to the program</span>
    glAttachShader(program, vs);
    glAttachShader(program, fs);

    <span class="hljs-comment">// Link the shaders into a program</span>
    glLinkProgram(program);

    <span class="hljs-comment">// Validate the program</span>
    glValidateProgram(program);

    <span class="hljs-comment">// Delete the individual shaders as they are now part of the program</span>
    glDeleteShader(vs);
    glDeleteShader(fs);

    <span class="hljs-comment">// Return the ID of the shader program</span>
    <span class="hljs-keyword">return</span> program;
}
</code></pre>
<ul>
<li><strong>Create Shader Program Object:</strong> <code>unsigned int program = glCreateProgram();</code> creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program.</li>
</ul>
<hr>
<ul>
<li><strong>Compile Shaders:</strong> The function calls <code>CompileShader</code> for both the vertex shader (<strong>GL_VERTEX_SHADER</strong>) and the fragment shader (<strong>GL_FRAGMENT_SHADER</strong>). The resulting shader IDs are stored in vs and fs.</li>
</ul>
<hr>
<ul>
<li><strong>Attach Shaders to Program:</strong> <code>glAttachShader(program, vs);</code> and <code>glAttachShader(program, fs)</code> attach the compiled vertex and fragment shaders to the shader program.
<img src="https://i.postimg.cc/m2bzcPQB/image.png" alt=""></li>
</ul>
<hr>
<ul>
<li><strong>Link Shaders:</strong> <code>glLinkProgram(program);</code> links the attached shaders into a complete shader program.</li>
</ul>
<hr>
<ul>
<li><strong>Validate Program:</strong> <code>glValidateProgram(program);</code> checks if the program can execute given the current OpenGL state. This step is optional but can be helpful for debugging.</li>
</ul>
<hr>
<ul>
<li><strong>Delete Individual Shaders:</strong> <code>glDeleteShader(vs);</code> and <code>glDeleteShader(fs);</code> delete the individual shaders now that they are attached to the program. This helps in freeing up resources.</li>
</ul>
<hr>
<ul>
<li><strong>Return Program ID:</strong> The function returns the ID of the created shader program.</li>
</ul>
<hr>
<p>These two shaders are example for creating a simple red color effect on the triangle, we don’t need to understand how it’s written now but it’s good to know</p>
<pre class="hljs"><code>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> vertexShader =
            <span class="hljs-string">&quot;#version 330 core&quot;</span>
            <span class="hljs-string">&quot;\n&quot;</span>
            <span class="hljs-string">&quot;layout(location = 0) in vec4 position;&quot;</span>
            <span class="hljs-string">&quot;\n&quot;</span>
            <span class="hljs-string">&quot;void main()\n&quot;</span>
            <span class="hljs-string">&quot;{\n&quot;</span>
            <span class="hljs-string">&quot;gl_Position = position;\n&quot;</span>
            <span class="hljs-string">&quot;}\n&quot;</span>;

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fragmentShader =
            <span class="hljs-string">&quot;#version 330 core&quot;</span>
            <span class="hljs-string">&quot;\n&quot;</span>
            <span class="hljs-string">&quot;layout(location = 0) out vec4 color;&quot;</span>
            <span class="hljs-string">&quot;\n&quot;</span>
            <span class="hljs-string">&quot;void main()\n&quot;</span>
            <span class="hljs-string">&quot;{\n&quot;</span>
            <span class="hljs-string">&quot;color = vec4(1.0,0.0,0.0,1.0);\n&quot;</span>
            <span class="hljs-string">&quot;}\n&quot;</span>;
</code></pre>
<p>Next we will use files to make writing more efficient and cleaner.</p>

            </div>

            <footer class="article-footer">
                <a href="/posts.html"><i class="fas fa-arrow-left"></i> All Posts</a>
                <a href="/">Home</a>
            </footer>
        </article>
    </div>

    <script>
    // Theme
    const toggleBtn = document.getElementById('theme-toggle');
    const themeIcon = document.getElementById('theme-icon');
    function setTheme(m) {
        document.body.classList.toggle('dark-mode', m === 'dark');
        themeIcon.className = m === 'dark' ? 'fa-solid fa-sun' : 'fa-solid fa-moon';
        localStorage.setItem('theme', m);
    }
    toggleBtn.addEventListener('click', () => setTheme(document.body.classList.contains('dark-mode') ? 'light' : 'dark'));
    if (localStorage.getItem('theme') === 'dark') setTheme('dark');

    document.getElementById('nav-hamburger').addEventListener('click', () => {
        document.getElementById('nav-links').classList.toggle('open');
    });

    // Copy buttons for code blocks
    document.querySelectorAll('pre.hljs').forEach(pre => {
        const wrapper = document.createElement('div');
        wrapper.className = 'code-wrapper';
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);

        const btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.textContent = 'Copy';
        wrapper.appendChild(btn);

        btn.addEventListener('click', () => {
            const code = pre.querySelector('code');
            navigator.clipboard.writeText(code ? code.textContent : pre.textContent);
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = 'Copy', 1500);
        });
    });
    </script>
    
</body>
</html>
