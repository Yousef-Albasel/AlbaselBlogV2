<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Software Engineering on Yousef Albael</title>
        <link>http://localhost:1313/categories/software-engineering/</link>
        <description>Recent content in Software Engineering on Yousef Albael</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 03 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/software-engineering/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Monolithic Software</title>
        <link>http://localhost:1313/post/monolithic-software/</link>
        <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/monolithic-software/</guid>
        <description>&lt;img src="http://localhost:1313/post/monolithic-software/ms.png" alt="Featured image of post Monolithic Software" /&gt;&lt;h3 id=&#34;what-is-meant-by-monolithic-architecture&#34;&gt;What is meant by monolithic architecture?
&lt;/h3&gt;&lt;p&gt;Monolithic architecture refers to a traditional software development model where all functions of an application are integrated into a single, tightly coupled codebase. This approach enables the handling of multiple related tasks within one unified system, but it also leads to challenges, as modifications in one area can significantly impact the entire codebase. In contrast to modular alternatives like microservices, which break down applications into independent components that can be developed, deployed, and scaled individually, monolithic architecture can be restrictive and time-consuming to update.&lt;/p&gt;
&lt;h3 id=&#34;lets-discover-different-aspects-of-monolithic-architecture&#34;&gt;Let’s discover different aspects of monolithic architecture:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Deployment&lt;/strong&gt;: Developers install the entire application code base and dependencies in a single environment, so it’s easier in comparison to alternatives like microservices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Development&lt;/strong&gt;: Starting a monolithic application is simpler since it requires less upfront planning. You can begin and continue to add code modules as required. Over time, though, the application may get complicated and difficult to update or modify.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Scaling&lt;/strong&gt;: As they scale, monolithic apps encounter a number of difficulties. The entire program must be scaled as needs change because the monolithic architecture houses all functionalities in a single code base.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;but-when-is-building-monolithic-software-preferable&#34;&gt;But when is building monolithic software preferable?
&lt;/h3&gt;&lt;p&gt;There are instances where using a monolithic architecture may be more beneficial than microservices. For example, Twilio&amp;rsquo;s Segment transitioned from a microservices approach to a monolithic one due to the complexities that microservices introduced, such as increased operational overhead, challenges in debugging, and the need for greater coordination among teams.&lt;/p&gt;
&lt;p&gt;Similarly, Amazon Prime Video initially implemented distributed components for its audio and video quality monitoring but found it too costly to maintain at scale. They ultimately decided to consolidate these components into a single monolithic application. These cases illustrate that a simpler, monolithic architecture can facilitate faster development cycles and reduce overhead.&lt;/p&gt;
&lt;h3 id=&#34;in-conclusion-monolithic-software-should-be-considered-when&#34;&gt;In conclusion, monolithic software should be considered when:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Project Simplicity&lt;/strong&gt;: The application is small and straightforward, requiring limited functionality.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rapid Development Needs&lt;/strong&gt;: There’s a need for quick delivery of a functional product without the complexities of managing multiple services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Limited Team Size&lt;/strong&gt;: The development team is small, making it easier to manage a single codebase rather than coordinating across multiple services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Low Scalability Requirements&lt;/strong&gt;: The application is not expected to grow significantly, making the overhead of a microservices architecture unnecessary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unified Deployment&lt;/strong&gt;: Components are tightly integrated and need to be deployed together, simplifying the deployment process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;most-common-architecture-styles-for-monolithic-software&#34;&gt;Most Common Architecture Styles for Monolithic Software:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layered Pattern&lt;/strong&gt;: This divides the monolith into logical layers, typically including a presentation layer (UI), a business layer (business logic), and a data layer (database operations).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Model-View-Controller (MVC)&lt;/strong&gt;: Common in web applications, MVC separates the application into three components: the model (data), the view (user interface), and the controller (handles input and updates).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pipe and Filter&lt;/strong&gt;: This pattern structures systems that process data streams, with each processing step encapsulated in a filter and connected by pipes for buffering or synchronization.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Client-Server&lt;/strong&gt;: In this architecture, the system is split into a server (providing services) and a client (accessing those services), often running on the same machine and communicating through function calls.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Blackboard&lt;/strong&gt;: This pattern addresses complex problems by allowing multiple specialized subsystems to contribute their knowledge to a central component (the blackboard), which contains structured information from the problem domain.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;advantages-of-monolithic-software&#34;&gt;Advantages of Monolithic Software:
&lt;/h3&gt;&lt;p&gt;Monolithic architecture offers several advantages, starting with its simplicity in development. It follows a standard approach, requiring no additional knowledge, as all source code is centralized in one location, making it easy to understand. Debugging is straightforward since all code is contained within a single unit, allowing for a clear trace of requests and issues. Testing is also simplified, as only one service needs to be tested without external dependencies. Deployment is efficient, involving just one unit, such as a jar file, and eliminating concerns about breaking changes when the UI is integrated with backend code.&lt;/p&gt;
&lt;p&gt;Moreover, the evolution of the application is seamless since there are no limitations from a business logic standpoint; necessary data for new features is already available. Cross-cutting concerns, such as security and logging, need to be addressed only once, streamlining the development process. Onboarding new team members becomes easier as the codebase is consolidated, enabling them to quickly debug and familiarize themselves with the application. Finally, during the early stages, the low cost of maintaining a single deployment unit minimizes infrastructure and development expenses, making it an attractive option for startups and small projects.&lt;/p&gt;
&lt;h3 id=&#34;references&#34;&gt;References:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/compare/the-difference-between-monolithic-and-microservices-architecture/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AWS: Monolithic vs Microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.akamai.com/blog/cloud/monolith-versus-microservices-weigh-the-difference&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Akamai: Monolith Versus Microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.designgurus.io/blog/monolithic-service-oriented-microservice-architecture&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Design Gurus: Monolithic vs Microservice Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://datamify.medium.com/monolithic-architecture-advantages-and-disadvantages-e71a603eec89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Datamify: Monolithic Architecture Advantages and Disadvantages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        
    </channel>
</rss>
