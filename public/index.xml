<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Yousef Albael</title>
        <link>http://localhost:1313/</link>
        <description>Recent content on Yousef Albael</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 05 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>About</title>
        <link>http://localhost:1313/page/about/</link>
        <pubDate>Tue, 05 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/page/about/</guid>
        <description>&lt;p&gt;My name is &lt;strong&gt;Yousef Albasel&lt;/strong&gt;, Iam a computer science student from Egypt interested in computer graphics, and AI. Pursuing my studies at Cairo University&amp;rsquo;s Faculty of Computers and Artificial Intelligence.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cu.edu.eg/ar/images/demo/slideshow/bg1.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;I started programming with web development, learning JavaScript frameworks, Django, and .NET development—but quickly realized this wasn’t my path. Turns out, I’m more of a low-level programming person. I like to dive deep into C and C++, reinventing the wheel pretty much every time. Some might call this self-inflicted suffering&amp;hellip; and honestly, they might be right!&lt;/p&gt;
&lt;p&gt;For fun, I started learning computer graphics. I wouldn’t say I’m great at it, but it’s been entertaining. The hardest part of my coding journey so far, hands down. I’ve put it on hold for now, but I’ll still post about it every once in a while.&lt;/p&gt;
&lt;p&gt;Recently, I joined Samsung’s Innovation Campus for AI, where I got introduced to machine learning and deep learning—and, well, I’m hooked. Training deep learning models and seeing the results is something I’ve completely fallen for, so expect to see a lot of that here.&lt;/p&gt;
&lt;p&gt;Currently, I’m a third-year computer science student, doing my best to stay sane. Wish me luck!&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Challenge One   Buffers</title>
        <link>http://localhost:1313/computer-graphics---opengl/challenges-and-notes/challenge-one---buffers/</link>
        <pubDate>Tue, 30 Jan 2024 22:26:53 +0200</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/challenges-and-notes/challenge-one---buffers/</guid>
        <description>&lt;h3 id=&#34;challenge-one---buffers&#34;&gt;Challenge One - Buffers
&lt;/h3&gt;&lt;p&gt;This is a challenge taken from the &lt;strong&gt;GamesWithGabe&lt;/strong&gt; channel, focusing on rendering simple triangles and creating/managing buffers.&lt;/p&gt;
&lt;p&gt;It comprises four mini-challenges:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First:&lt;/strong&gt; Draw a square on the screen using &lt;code&gt;glDrawArrays.&lt;/code&gt; Remember to store your vertex positions in normalized device coordinates, ranging from -1 to 1 in the &lt;strong&gt;x&lt;/strong&gt; and &lt;strong&gt;y&lt;/strong&gt; directions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second:&lt;/strong&gt; Draw a square on the screen using &lt;code&gt;glDrawElements&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Third:&lt;/strong&gt; Draw a star using &lt;code&gt;glDrawElements&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fourth:&lt;/strong&gt; Draw the outline of a square using the &lt;code&gt;GL_LINES&lt;/code&gt; primitive.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fifth:&lt;/strong&gt; Repeat the star challenge, but utilize the named buffer technique we just discussed.&lt;/p&gt;
&lt;p&gt;To be honest, I&amp;rsquo;m not interested in the fifth challenge because it relies on a function introduced only in &lt;strong&gt;GL4&lt;/strong&gt;, and not all devices may support it. So, I&amp;rsquo;ll focus on the other challenges&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;first-challenge-solution&#34;&gt;First Challenge Solution
&lt;/h4&gt;&lt;p&gt;Here is the code for the first challenge without all the hassle of creating windows and shaders etc..&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// The Current Challenge is: Draw a square on the screen using glDrawArrays. Remember to store your vertex positions in normalized device coordinates, ranging from -1 to 1 in the x and y directions
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// First let&amp;#39;s create our vertices
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; vertices[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Next let&amp;#39;s create a VAO to bind our buffer with
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; VAO;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    glGenVertexArrays(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;VAO);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    glBindVertexArray (VAO);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Now that we have our VAO, we can create a buffer to store these vertices in.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; VBO;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    glGenBuffers(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;VBO);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    glBindBuffer(GL_ARRAY_BUFFER, VBO);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Now let&amp;#39;s copy the data in our vertices array to the buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    glBufferData(GL_ARRAY_BUFFER, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt;), vertices, GL_STATIC_DRAW);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// But sadly, our GPU doesn&amp;#39;t know how our data stored in the buffer.. :( 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// we need to specify it for him, using attrib pointers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    glEnableVertexAttribArray(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// Enabling location 1 in the vertex array 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    glVertexAttribPointer(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, GL_FLOAT, GL_FALSE, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt;), (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Creating simple shader to use ( we don&amp;#39;t need to worry about it atm so i will not include it in the blog.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;second-challenge-solution&#34;&gt;Second Challenge Solution
&lt;/h4&gt;&lt;p&gt;This one pretty easy, all we have to do is to get rid of redundunt data, create index buffer, bind it and copy data, finally draw elements.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Now for Challenge Two, we need to create index buffer so we can save more data !
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; indices[]{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Creating the element buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; EBO;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glGenBuffers&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;EBO);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glBindBuffer&lt;/span&gt;(GL_ELEMENT_ARRAY_BUFFER, EBO);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glBufferData&lt;/span&gt;(GL_ELEMENT_ARRAY_BUFFER, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;), indices, GL_STATIC_DRAW);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;inside main loop:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glDrawElements&lt;/span&gt;(GL_TRIANGLES, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, GL_UNSIGNED_INT, NULL);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;third-challenge&#34;&gt;Third Challenge
&lt;/h4&gt;</description>
        </item>
        <item>
        <title>Handwritten Notes on VAO,VBO</title>
        <link>http://localhost:1313/computer-graphics---opengl/challenges-and-notes/handwritten-notes-on-vaovbo/</link>
        <pubDate>Tue, 30 Jan 2024 22:26:25 +0200</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/challenges-and-notes/handwritten-notes-on-vaovbo/</guid>
        <description>&lt;h3 id=&#34;notes-taken-on-vbos-vaos-and-some-other-interesting-stuff&#34;&gt;Notes taken on VBO&amp;rsquo;S ,VAO&amp;rsquo;s and some other interesting stuff
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/9MstWW74/Cam-Scanner-01-30-2024-22-13-page-0001.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://i.postimg.cc/GtYPtZFX/Cam-Scanner-01-30-2024-22-13-page-0002.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/Gmr0LRFS/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/mDPJXg4h/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Intro to Shaders | OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p4.1---shaders/</link>
        <pubDate>Sun, 28 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p4.1---shaders/</guid>
        <description>&lt;h2 id=&#34;how-shaders-work-in-opengl&#34;&gt;How Shaders Work in OpenGL
&lt;/h2&gt;&lt;p&gt;A shader is just a program that runs on your GPU. By program, we mean a block of code. It&amp;rsquo;s code that we can write as text, then send to the graphics card to compile and link, like any other program. However, it actually runs on our GPU, not CPU. So, why do we need programs that run on the GPU? We learn about graphics programming to utilize the power of the GPU and minimize the load on the CPU. Though some operations are preferably done on the CPU, undoubtedly, a lot of processes we perform in graphics programming are better done on the GPU.&lt;/p&gt;
&lt;h4 id=&#34;a-vertex-shaders&#34;&gt;&lt;strong&gt;A. Vertex Shaders&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;When we issue a draw call, what happens is the vertex shader gets called, then the fragment shader gets called. There are many stages between them, but let&amp;rsquo;s keep it simple for now. The point is, we go from the draw call to the vertex shader to the fragment shader to see things on the screen. So, a vertex shader gets called for each vertex we are trying to render.&lt;/p&gt;
&lt;p&gt;The primary purpose of a vertex shader is to inform OpenGL about the location in your window where you would like that vertex to be. It doesn&amp;rsquo;t have anything to do with color or other visual aspects; its main role is to specify positions and pass data to the next stage, which is the fragment shader.&lt;/p&gt;
&lt;p&gt;Consider this scenario: you have a camera in a 3D world positioned in a certain way. Suddenly, the position we specified for our triangle won&amp;rsquo;t translate directly, as the movements of the camera mean the triangle moves as well. So, it&amp;rsquo;s not as trivial as it may seem.&lt;/p&gt;
&lt;p&gt;The transformations applied in the vertex shader contribute to the final positions of vertices on the screen, creating the illusion of movement and interaction in the rendered scene.&lt;/p&gt;
&lt;h4 id=&#34;b-fragment-shaders&#34;&gt;B. Fragment Shaders
&lt;/h4&gt;&lt;p&gt;The next stage in our pipeline is the pixel shader, also known as the fragment shader. It runs once for each pixel that needs to be drawn on the screen. Since our window is essentially made up of pixels, the task is to fill the space between the three vertices with pixels. It is called once for each pixel within our triangle, with its primary purpose being to determine the color to contribute to our triangle.&lt;/p&gt;
&lt;p&gt;While the vertex shader may not be called as frequently, the fragment shader gets called thousands or millions of times. For instance, if we perform a computation like 5 times 5 in the vertex shader, that operation happens three times for each vertex. In contrast, in the fragment shader (which is called thousands of times), the difference becomes apparent. It&amp;rsquo;s essential to keep in mind that operations in the vertex shader are carried out a few times and then passed, whereas operations in the fragment shader tend to be more computationally expensive.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Index Buffers in OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p5---index-buffers/</link>
        <pubDate>Fri, 26 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p5---index-buffers/</guid>
        <description>&lt;h4 id=&#34;index-buffers&#34;&gt;Index Buffers
&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;When we draw shapes like triangles, using the same vertex positions repeatedly can lead to unnecessary memory duplication. Imagine drawing a triangle; you would have three vertices at the corners, and each vertex has its position information. If you want to draw another triangle to form a square, you&amp;rsquo;d end up storing the same vertex positions again, leading to redundancy in memory usage.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; positions[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// redundunt
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                             &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;//redundunt
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        };
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Index Buffers it&amp;rsquo;s like having a shared list of vertices, and the index buffer tells the graphics system which vertices to use for each triangle. This approach not only reduces memory consumption but also improves rendering efficiency, especially when dealing with complex 3D models composed of numerous triangles.&lt;/p&gt;
&lt;p&gt;so what we gonna do is to get rid of the two redundant vertices and create an array for indices&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; indices[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        };
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;next we create an index buffer of type &lt;code&gt;GL_ELEMENT_ARRAY_BUFFER&lt;/code&gt; and bind it so we can use this index buffer to draw whatever shapes we want&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Index Buffer creating
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ibo;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glGenBuffers&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ibo); &lt;span style=&#34;color:#75715e&#34;&gt;// Generates a buffer and gives back ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glBindBuffer&lt;/span&gt;(GL_ELEMENT_ARRAY_BUFFER, ibo); &lt;span style=&#34;color:#75715e&#34;&gt;// binding to the buffer we created.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glBufferData&lt;/span&gt;(GL_ELEMENT_ARRAY_BUFFER, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;), indices, GL_STATIC_DRAW);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;last thing we want to do is to modify the draw method we used, this time we will use a &lt;code&gt;glDrawElement()&lt;/code&gt; method to draw our shape.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glDrawElements&lt;/span&gt;(GL_TRIANGLES,&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;,GL_UNSIGNED_INT,NULL); &lt;span style=&#34;color:#75715e&#34;&gt;// use if you don&amp;#39;t have a index buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/j5Yg9VfM/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Vertex Layout in OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p3---vertex-layout/</link>
        <pubDate>Wed, 24 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p3---vertex-layout/</guid>
        <description>&lt;h3 id=&#34;vertex-layout&#34;&gt;Vertex Layout
&lt;/h3&gt;&lt;p&gt;A vertex is not a position, it can contain more data than just position, but most of the time it&amp;rsquo;s a position, it can be polynomials, tangents,trignometry or other things.&lt;/p&gt;
&lt;p&gt;Now that we created a buffer, filled it with data we need to tell OpenGL that we are now trying to create a 2D Layout&lt;/p&gt;
&lt;h5 id=&#34;glenablevertexattribarray0&#34;&gt;glEnableVertexAttribArray(0);
&lt;/h5&gt;&lt;p&gt;This line enables the generic vertex attribute array with index 0. In OpenGL, a vertex attribute array is a set of attributes associated with a vertex. By enabling it, you&amp;rsquo;re indicating that data for this attribute will be sourced from an array.&lt;/p&gt;
&lt;h5 id=&#34;glvertexattribpointer0-2-gl_float-gl_false-sizeoffloat--2-0&#34;&gt;glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
&lt;/h5&gt;&lt;p&gt;This function call defines an array of vertex attribute data. Breaking it down:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;0 specifies that this attribute is associated with index 0, which matches the index enabled with glEnableVertexAttribArray(0).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 indicates that each vertex attribute is composed of two components (in this case, x and y for 2D coordinates).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GL_FLOAT specifies the type of data in the array (float in this case).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GL_FALSE indicates whether the data should be normalized. In this case, it&amp;rsquo;s set to false.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sizeof(float) * 2 is the stride, which specifies the byte offset between consecutive generic vertex attributes. It tells OpenGL the size of each vertex in memory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0 is the pointer offset. It specifies the offset of the first component of the first generic vertex attribute in the array.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Now we need to tell OpenGL how our data is laid out, is it a 2D Vector or 3D...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glEnableVertexAttribArray&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glVertexAttribPointer&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, GL_FLOAT, GL_FALSE, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Basic Concepts in OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p1.1---extra-information/</link>
        <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p1.1---extra-information/</guid>
        <description>&lt;h2 id=&#34;i-still-dont-know-what-opengl-glew-glfw-are&#34;&gt;I still don&amp;rsquo;t know what (OpenGL, GLEW, GLFW) are..
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;I&amp;rsquo;ve been searching, here is what i found.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;so, OpenGL is not a library.
It is a specification.
Just a few (quite a few, actually) pages of text!
You can see it here &lt;a class=&#34;link&#34; href=&#34;https://registry.khronos.org/OpenGL/specs/gl/glspec44.core.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://registry.khronos.org/OpenGL/specs/gl/glspec44.core.pdf&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Then we can conclude that you can’t “install” OpenGL. But, you might ask, &lt;strong&gt;where does the code exist?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, &lt;strong&gt;OpenGL&lt;/strong&gt; standard is already implemented inside of the your &lt;strong&gt;OS GPU&lt;/strong&gt; driver, by manufacturers, without any kind of agreements on the actual implementation, and, so, different drivers may achieve the same functionality in a different ways. and we use &lt;strong&gt;opengl32.lib&lt;/strong&gt; to communicate with this driver.&lt;/p&gt;
&lt;p&gt;to start actually displaying something in the screen, you need to have access to 2 things.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;the concrete OpenGL implementation functionality.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Setup the windowing system &amp;amp; OpenGL context.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both of these things require some interaction with the operating system: In order to load OpenGL implementation function pointers, and, also, in order to create a window.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;So, we use a library to do that for us, here comes GLEW&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GLEW (stands for OpenGL Extension Wrangler Library) is a cross-platform C/C++ library that helps in querying and loading OpenGL extensions.&lt;/p&gt;
&lt;p&gt;OpenGL extensions are a means for OpenGL implementations to provide new or expanded functionality that the core of OpenGL does not provide&lt;/p&gt;
&lt;p&gt;and GLFW for Window Handling.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Errors and Uniforms in OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p6---errors-and-uniforms/</link>
        <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p6---errors-and-uniforms/</guid>
        <description>&lt;h2 id=&#34;errors-in-opengl&#34;&gt;Errors in OpenGL
&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;OpenGL doesn&amp;rsquo;t provide a clear error logging so we will create one, without getting in much details here is the code that we created&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ASSERT(x) if (!(x)) __debugbreak();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define GLCall(x) GLClearError();\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    x;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    ASSERT(GLLogCall(#x,__FILE__,__LINE__))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GLClearError&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;glGetError&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; GL_NO_ERROR) ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GLLogCall&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; function,&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; file,&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; line) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (GLenum error &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;glGetError&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[OPENGL ERROR] (&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; error &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;):&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; function &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In simple terms, we are defining two macros: one for ASSERT, which will halt the application and mark the error&amp;rsquo;s position with a break point, and another for automatically calling GLClearError, which will display the error line, file name, location, etc. only for the sake of clean code&lt;/p&gt;
&lt;p&gt;now each time we want to check if a function call returns an error we can use GLCall(); eg:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GLCall&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;glDrawElements&lt;/span&gt;(GL_TRIANGLES, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, GL_UNSIGNED_INT, nullptr));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and that&amp;rsquo;s it, next we cover uniforms in OpenGL.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;uniforms&#34;&gt;Uniforms
&lt;/h2&gt;&lt;p&gt;Uniforms are basically like a variable that gets assigned in a shader then manipulated inside our c++ program so for example if i modify our fragment shader to have a
&lt;code&gt;uniform vec4 uColor;&lt;/code&gt; then use it in our shader.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void main()
{
	color = u_Color;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;what we can do now is to find the location of that uniform call and update the values in real time inside our render loop&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;GLCall&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; location &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;glGetUniformLocation&lt;/span&gt;(shader, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;u_Color&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;ASSERT&lt;/span&gt;(location &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;GLCall&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;glUniform4f&lt;/span&gt;(location,&lt;span style=&#34;color:#ae81ff&#34;&gt;0.2f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0.3f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0.4f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Loop until the user closes the window */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; increment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.05f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;inside render loop:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;GLCall&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;glUniform4f&lt;/span&gt;(location, r,&lt;span style=&#34;color:#ae81ff&#34;&gt;0.4f&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0.3f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;GLCall&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;glDrawElements&lt;/span&gt;(GL_TRIANGLES, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, GL_UNSIGNED_INT, nullptr));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (r &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.05f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;if&lt;/span&gt; (r &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.05f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; increment;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Intro to Shaders 2 | OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p4.2---shaders/</link>
        <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p4.2---shaders/</guid>
        <description>&lt;h4 id=&#34;writing-our-own-shader&#34;&gt;Writing our own Shader
&lt;/h4&gt;&lt;p&gt;The plan is to create a function that takes &lt;strong&gt;vertexShader&lt;/strong&gt;, &lt;strong&gt;fragmentShader&lt;/strong&gt; source codes, compile them and provide a &amp;ldquo;&lt;strong&gt;program&lt;/strong&gt;&amp;rdquo; that works as a shader for our triangle.&lt;/p&gt;
&lt;p&gt;First let&amp;rsquo;s define a function that compiles shader string &lt;strong&gt;( we will basically write code in a string that opengl can later read it)&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompileShader&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; type, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; source) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Create a shader object of the specified type
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;glCreateShader&lt;/span&gt;(type);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Get a pointer to the C string of the source code
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; src &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; source.&lt;span style=&#34;color:#a6e22e&#34;&gt;c_str&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Provide the shader source code to OpenGL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glShaderSource&lt;/span&gt;(id, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;src, nullptr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Compile the shader
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glCompileShader&lt;/span&gt;(id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Check for compilation errors
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glGetShaderiv&lt;/span&gt;(id, GL_COMPILE_STATUS, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;result);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (result &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; GL_FALSE) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// If there&amp;#39;s an error, retrieve the error message
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glGetShaderiv&lt;/span&gt;(id, GL_INFO_LOG_LENGTH, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;length);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Allocate memory on the stack for the error message
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; message &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#a6e22e&#34;&gt;alloca&lt;/span&gt;(length &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Retrieve the error message
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glGetShaderInfoLog&lt;/span&gt;(id, length, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;length, message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Print the error message
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Fail to Compile Shader: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; message &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Delete the shader as it&amp;#39;s not needed anymore
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glDeleteShader&lt;/span&gt;(id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Return 0 to indicate failure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Return the ID of the successfully compiled shader
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; id;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create Shader Object:&lt;/strong&gt; unsigned int id = glCreateShader(type); creates a shader object of the specified type (&lt;strong&gt;GL_VERTEX_SHADER&lt;/strong&gt; or &lt;strong&gt;GL_FRAGMENT_SHADER&lt;/strong&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/fWm1rLS4/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Provide Source Code:&lt;/strong&gt; &lt;code&gt;const char* src = source.c_str();&lt;/code&gt; gets a pointer to the C string of the shader source code provided as a parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Set Shader Source:&lt;/strong&gt; &lt;code&gt;glShaderSource(id, 1, &amp;amp;src, nullptr);&lt;/code&gt; provides the shader source code to OpenGL.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/fWm1rLS4/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compile Shader:&lt;/strong&gt; &lt;code&gt;glCompileShader(id); &lt;/code&gt;compiles the shader. glCompileShader compiles the source code strings that have been stored in the shader object specified by shader&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The compilation status will be stored as part of the shader object&amp;rsquo;s state. This value will be set to GL_TRUE if the shader was compiled without errors and is ready for use, and GL_FALSE otherwise. It can be queried by calling glGetShader with arguments shader and GL_COMPILE_STATUS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/KjWKTNPV/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Check Compilation Status:&lt;/strong&gt; &lt;code&gt;(id, GL_COMPILE_STATUS,  &amp;amp;result); &lt;/code&gt;checks if the compilation was successful.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/SNrSHVYp/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Handle Compilation Errors:&lt;/strong&gt; If there&amp;rsquo;s an error, the function retrieves and prints the error message using &lt;code&gt;glGetShaderInfoLog&lt;/code&gt; and deallocates the shader object. The error message is printed to the console.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/SNrSHVYp/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Return Shader ID:&lt;/strong&gt; If the compilation is successful, it returns the ID of the compiled shader for later use.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;The fundamental purpose of the &lt;code&gt;CreateShader&lt;/code&gt; function is to perform a couple of tasks, but at its core, we need to supply OpenGL with the code text. Afterward, it links both components together and returns a unique identifier. This identifier allows us to bind the shader and use it, akin to how we generate a buffer that provides us with an ID, which we can then bind to access and utilize.&lt;/p&gt;
&lt;p&gt;so the function takes two sources codes, sends them to compile function, then returns &lt;code&gt;Gluint&lt;/code&gt; type shader that we can bind and use for our triangle.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CreateShader&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; vertexShader, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; fragmentShader) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Create a shader program object
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; program &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;glCreateProgram&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Compile the vertex and fragment shaders
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; vs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompileShader&lt;/span&gt;(GL_VERTEX_SHADER, vertexShader);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompileShader&lt;/span&gt;(GL_FRAGMENT_SHADER, fragmentShader);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Attach the compiled shaders to the program
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glAttachShader&lt;/span&gt;(program, vs);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glAttachShader&lt;/span&gt;(program, fs);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Link the shaders into a program
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glLinkProgram&lt;/span&gt;(program);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Validate the program
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glValidateProgram&lt;/span&gt;(program);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Delete the individual shaders as they are now part of the program
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glDeleteShader&lt;/span&gt;(vs);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glDeleteShader&lt;/span&gt;(fs);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Return the ID of the shader program
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; program;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create Shader Program Object:&lt;/strong&gt; &lt;code&gt;unsigned int program = glCreateProgram();&lt;/code&gt; creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compile Shaders:&lt;/strong&gt; The function calls &lt;code&gt;CompileShader&lt;/code&gt; for both the vertex shader (&lt;strong&gt;GL_VERTEX_SHADER&lt;/strong&gt;) and the fragment shader (&lt;strong&gt;GL_FRAGMENT_SHADER&lt;/strong&gt;). The resulting shader IDs are stored in vs and fs.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Attach Shaders to Program:&lt;/strong&gt; &lt;code&gt;glAttachShader(program, vs);&lt;/code&gt; and &lt;code&gt;glAttachShader(program, fs)&lt;/code&gt; attach the compiled vertex and fragment shaders to the shader program.
&lt;img src=&#34;https://i.postimg.cc/m2bzcPQB/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Link Shaders:&lt;/strong&gt; &lt;code&gt;glLinkProgram(program);&lt;/code&gt; links the attached shaders into a complete shader program.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Validate Program:&lt;/strong&gt; &lt;code&gt;glValidateProgram(program);&lt;/code&gt; checks if the program can execute given the current OpenGL state. This step is optional but can be helpful for debugging.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Delete Individual Shaders:&lt;/strong&gt; &lt;code&gt;glDeleteShader(vs);&lt;/code&gt; and &lt;code&gt;glDeleteShader(fs);&lt;/code&gt; delete the individual shaders now that they are attached to the program. This helps in freeing up resources.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Return Program ID:&lt;/strong&gt; The function returns the ID of the created shader program.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;These two shaders are example for creating a simple red color effect on the triangle, we don&amp;rsquo;t need to understand how it&amp;rsquo;s written now but it&amp;rsquo;s good to know&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string vertexShader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#version 330 core&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;layout(location = 0) in vec4 position;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;void main()&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gl_Position = position;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string fragmentShader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#version 330 core&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;layout(location = 0) out vec4 color;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;void main()&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;color = vec4(1.0,0.0,0.0,1.0);&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next we will use files to make writing more efficient and cleaner.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Intro to Shaders 3 | OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p4.3---shaders/</link>
        <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p4.3---shaders/</guid>
        <description>&lt;h4 id=&#34;better-way-to-write-shaders&#34;&gt;Better way to write shaders
&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;The last time we made a shader, we used a string for the code, which was a bit inconvenient. A better way to handle shaders is by creating a shader parser function. This function can read the shader file and split it into the vertex and fragment shaders.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// This struct for using it later so we can return two variables
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; ShaderProgramSource {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string   VertexSource;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string FragmentSource;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; ShaderProgramSource &lt;span style=&#34;color:#a6e22e&#34;&gt;ParseShader&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; filepath) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; class ShaderType { &lt;span style=&#34;color:#75715e&#34;&gt;// enum to determine the index in the string stream array
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        NONE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, VERTEX &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, FRAGMENT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fstream stream;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stream.&lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(filepath);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;stream.&lt;span style=&#34;color:#a6e22e&#34;&gt;is_open&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error: File is not opened&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;{ &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string line;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;stringstream ss[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ShaderType type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ShaderType&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;NONE;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;getline&lt;/span&gt;(stream, line))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (line.&lt;span style=&#34;color:#a6e22e&#34;&gt;find&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#shader&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;npos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (line.&lt;span style=&#34;color:#a6e22e&#34;&gt;find&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;vertex&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;npos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;//set mode to vertex
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ShaderType&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;VERTEX;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (line.&lt;span style=&#34;color:#a6e22e&#34;&gt;find&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fragment&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;npos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// set mode to fragment
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ShaderType&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;FRAGMENT;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// a clever way was to access the string stream array using a cast of the type enum to an int so it&amp;#39;s a lot easier and kinda automatic.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ss[static_cast&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(type)] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stream.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; { ss[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;str&lt;/span&gt;(),ss[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;str&lt;/span&gt;() };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The code is self explantory.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Textures in OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p7---textures-in-opengl/</link>
        <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p7---textures-in-opengl/</guid>
        <description>&lt;h3 id=&#34;textures-in-opengl&#34;&gt;Textures in OpenGL
&lt;/h3&gt;&lt;p&gt;All the code we need to assign a texture to a rectangle is as follows :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; texture;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glGenTextures&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;texture);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glBindTexture&lt;/span&gt;(GL_TEXTURE_2D, texture);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// set the texture wrapping/filtering options (on the currently bound texture object)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// load and generate the texture
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; width, height, nrChannels;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stbi_load&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;src/container.jpg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;width, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;height, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nrChannels, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glTexImage2D&lt;/span&gt;(GL_TEXTURE_2D, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, GL_RGB, width, height, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, GL_RGB, GL_UNSIGNED_BYTE, data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glGenerateMipmap&lt;/span&gt;(GL_TEXTURE_2D);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to load texture&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;stbi_image_free&lt;/span&gt;(data);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In order to map a texture to the triangle we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a texture coordinate associated with them that specifies what part of the texture image to sample from. Fragment interpolation then does the rest for the other fragments.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;We can do that in the vertices array and edit out attribute pointers to fit with it.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;texture-wrapping&#34;&gt;&lt;strong&gt;Texture Wrapping&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;Texture coordinates usually range from (0,0) to (1,1) but what happens if we specify coordinates outside this range? The default behavior of OpenGL is to repeat the texture images (we basically ignore the integer part of the floating point texture coordinate), but there are more options OpenGL offers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GL_REPEAT&lt;/strong&gt; : The default behavior for textures. Repeats the texture image.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GL_MIRRORED_REPEAT&lt;/strong&gt; : Same as GL_REPEAT but mirrors the image with each repeat.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GL_CLAMP_TO_EDGE&lt;/strong&gt; : Clamps the coordinates between 0 and 1. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GL_CLAMP_TO_BORDER&lt;/strong&gt; : Coordinates outside the range are now given a user-specified border color.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Specified in our code here&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://open.gl/media/img/c3_clamping.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;texture-filtering&#34;&gt;Texture Filtering
&lt;/h4&gt;&lt;p&gt;Texture coordinates do not depend on resolution but can be any floating point value, thus OpenGL has to figure out which texture pixel (also known as a texel ) to map the texture coordinate to. This becomes especially important if you have a very large object and a low resolution texture. You probably guessed by now that OpenGL has options for this texture filtering as well. There are several options available but for now we&amp;rsquo;ll discuss the most important options: GL_NEAREST and GL_LINEAR.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GL_NEAREST&lt;/strong&gt; (also known as nearest neighbor or point filtering) is the default texture filtering method of OpenGL. When set to GL_NEAREST, OpenGL selects the texel that center is closest to the texture coordinate. Below you can see 4 pixels where the cross represents the exact texture coordinate. The upper-left texel has its center closest to the texture coordinate and is therefore chosen as the sampled color:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GL_LINEAR&lt;/strong&gt; (also known as (bi)linear filtering) takes an interpolated value from the texture coordinate&amp;rsquo;s neighboring texels, approximating a color between the texels. The smaller the distance from the texture coordinate to a texel&amp;rsquo;s center, the more that texel&amp;rsquo;s color contributes to the sampled color. Below we can see that a mixed color of the neighboring pixels is returned:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.hiperaktif.org/uploads/articles/textureoutput55649.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://slideplayer.com/slide/17906772/108/images/43/Bi-linear&amp;#43;filtering&amp;#43;%28GL_LINEAR%29.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glTexParameteri&lt;/span&gt;(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;mipmaps&#34;&gt;Mipmaps
&lt;/h3&gt;&lt;p&gt;Imagine we had a large room with thousands of objects, each with an attached texture. There will be objects far away that have the same high resolution texture attached as the objects close to the viewer. Since the objects are far away and probably only produce a few fragments, OpenGL has difficulties retrieving the right color value for its fragment from the high resolution texture, since it has to pick a texture color for a fragment that spans a large part of the texture. This will produce visible artifacts on small objects, not to mention the waste of memory bandwidth using high resolution textures on small objects.&lt;/p&gt;
&lt;p&gt;To solve this issue OpenGL uses a concept called mipmaps that is basically a collection of texture images where each subsequent texture is twice as small compared to the previous one. The idea behind mipmaps should be easy to understand: after a certain distance threshold from the viewer, OpenGL will use a different mipmap texture that best suits the distance to the object. Because the object is far away, the smaller resolution will not be noticeable to the user. OpenGL is then able to sample the correct texels, and there&amp;rsquo;s less cache memory involved when sampling that part of the mipmaps. Let&amp;rsquo;s take a closer look at what a mipmapped texture looks like:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GL_NEAREST_MIPMAP_NEAREST&lt;/strong&gt; : takes the nearest mipmap to match the pixel size and uses nearest neighbor interpolation for texture sampling.
&lt;strong&gt;GL_LINEAR_MIPMAP_NEAREST&lt;/strong&gt; : takes the nearest mipmap level and samples that level using linear interpolation.
&lt;strong&gt;GL_NEAREST_MIPMAP_LINEAR&lt;/strong&gt; : linearly interpolates between the two mipmaps that most closely match the size of a pixel and samples the interpolated level via nearest neighbor interpolation.
&lt;strong&gt;GL_LINEAR_MIPMAP_LINEAR&lt;/strong&gt; : linearly interpolates between the two closest mipmaps and samples the interpolated level via linear interpolation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://f.hubspotusercontent10.net/hubfs/2426966/Imported_Blog_Media/example_mipmap_chain-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// load and generate the texture
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; width, height, nrChannels;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stbi_load&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;src/container.jpg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;width, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;height, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;nrChannels, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glTexImage2D&lt;/span&gt;(GL_TEXTURE_2D, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, GL_RGB, width, height, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, GL_RGB, GL_UNSIGNED_BYTE, data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glGenerateMipmap&lt;/span&gt;(GL_TEXTURE_2D);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to load texture&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;stbi_image_free&lt;/span&gt;(data);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;The first argument specifies the texture target; setting this to GL_TEXTURE_2D means this operation will generate a texture on the currently bound texture object at the same target (so any textures bound to targets GL_TEXTURE_1D or GL_TEXTURE_3D will not be affected).&lt;/li&gt;
&lt;li&gt;The second argument specifies the mipmap level for which we want to create a texture for if you want to set each mipmap level manually, but we&amp;rsquo;ll leave it at the base level which is 0.&lt;/li&gt;
&lt;li&gt;The third argument tells OpenGL in what kind of format we want to store the texture. Our image has only RGB values so we&amp;rsquo;ll store the texture with RGB values as well.&lt;/li&gt;
&lt;li&gt;The 4th and 5th argument sets the width and height of the resulting texture. We stored those earlier when loading the image so we&amp;rsquo;ll use the corresponding variables.&lt;/li&gt;
&lt;li&gt;The next argument should always be 0 (some legacy stuff).
The 7th and 8th argument specify the format and datatype of the source image. We loaded the image with RGB values and stored them as chars (bytes) so we&amp;rsquo;ll pass in the corresponding values.
The last argument is the actual image data.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Transformations and Projection OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p8---transitions-and-projection/</link>
        <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p8---transitions-and-projection/</guid>
        <description>&lt;h3 id=&#34;transformations-and-projection&#34;&gt;Transformations And Projection
&lt;/h3&gt;&lt;p&gt;In OpenGL, the way we manipulate vertices are using linear transformations, which is simple linear algebra operations like matrix multiplication, addition, Matrix-Vector product, etc..&lt;/p&gt;
&lt;p&gt;We mainly have 3 kinds of linear transformations, &lt;strong&gt;translate&lt;/strong&gt;, &lt;strong&gt;scale&lt;/strong&gt; and &lt;strong&gt;rotate&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;translate&#34;&gt;Translate
&lt;/h3&gt;&lt;p&gt;To see why we&amp;rsquo;re working with 4-by-1 vectors and subsequently 4-by-4 transformation matrices, let&amp;rsquo;s see how a translation matrix is formed. A translation moves a vector a certain distance in a certain direction.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://open.gl/media/img/c4_translation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAT4AAACHCAMAAAC4VMULAAABy1BMVEX///8AAAD&amp;#43;0pUAks////K88v8AAD&amp;#43;uPgDt//8AAE7//&amp;#43;YAPpv///vz//8AAAhJAAB&amp;#43;6P8AUKj4rVL///ZoBwC08v/n//8AAHP/9tAATZsAACbfkkj//&amp;#43;7/78F2AABpAADXgjm0TQBaAAAtAAAAcbWOAAAAAGcAJoz//9//2JwIn9TT//8AZa8/s&amp;#43;Pin1X8yI&amp;#43;qWgD/79dvzfClpqWA2PPy8vLIZQD/3ar&amp;#43;0p3zvX8AAHyb4fyCJgDd3d0AAFtzyPDkmFaWJgCjeliLyOfAZSAAWqit4fP/5sJmn8rf9v&amp;#43;V7//Nzc2lcTqYAABcrdrK5vf6uWcAicrYw73hiRgAervLehz3yKuUuMS6gkn57&amp;#43;XKw87KmG7JgjkNs&amp;#43;P4w35/yNOcPgDa0qMAPj4AABuiWgDtrW3FcQDMraUFcZSjrcTr2MjVuJ5liYJtTVrvuJBgcWXQ2MKucR63zedHrePAZTtFJgAAWpreyI&amp;#43;9PgCO0s2Ygq6gZYp2ACY2TWapJAAAPmZmJgC8enrPgmQAPovZ8uW5n7lSPj5JAFsAPnzjuIe8mFaYgnBaWnu6gnCBZSB0n9RJAHwAJj9AZWVlZTt6erSHTYuMs9maTT10Jlue2fDmAAALxUlEQVR4nO1d&amp;#43;2MUVxmdm2xJswxsyVqYZHeyJGlKAjHJAskmSJAUU2wLBYGgibG10mBFixXrs0pttWqq9V31z3Ue&amp;#43;5jd&amp;#43;z3mfrO7s&amp;#43;CcHwLZu9&amp;#43;ZO&amp;#43;e&amp;#43;75y5sawMGTJkyDBIWBlgNg0HM2d7ewEaiydutH9Q/dHhZ6WxOgzYGDiVrx7RPizvqSvdoZdiXb0e/bVWWDgujdVhxMagOnvqmY6P8ssTL3eLXooldbr1y5q6o5dxzFgdhmwM8iOjz7d/UlKpttwQ&amp;#43;&amp;#43;qLjf&amp;#43;6hXGz2hKJ1WHMxsCZvXAm&amp;#43;ntNfa2b9ELkli/VW0Vx9dDz9HfxWB3mbBzW2ip7bvlF9Nr9RLMU5&amp;#43;m2SMbqELAxsO9HC2St6/wy2Nthp1JcNS/ORqwOCRuHmhpuXfn&amp;#43;pS5Xbinq5RjNnGmsDhEbg&amp;#43;Jqq69wJhe6zi9DfvOw38cvqi&amp;#43;JY3WI2Disqy83/ruGjFrVa2ixVV9SahSbKJKJNEp&amp;#43;Cyyutg9sJrE6hGwM3EJTm32weKrXFFrrnUl1pbrcKoD4iQzW/QmUMytqDevw5EvIxiC/eayxiimdgIrn7te/gcp30k9xC3CXTCZ6qD7Cc&amp;#43;XOBLE/xr/BxAIfm7AVN6LT61uv4N/cbnR&amp;#43;5RFkOTiEyedUJrz6WvwK2OjJRA9z14me3KkM&amp;#43;0sI0Rw&amp;#43;iNVhxDYU/fI6NV1cbHQVuZEFeEWDyjevgvq6qKBAMtGyrl6kmnVuZNi/LtSZ7Ny64f3YxStEEKvDiC0iX&amp;#43;6bChmLwm8eeoa8LCHfuhr362sJ5CcTrZtK4V1qQz5gDCjuBWG31R06VocRW0u&amp;#43;uUkvo0T1SyCfJ42v0JKCWj2Z6Ku79Sy&amp;#43;9RbKB&amp;#43;Z6TW0d8X68gK79MflM2ObV&amp;#43;cZ/85vqCrFHGJEPKVFOviFKPjjRsi4rqicP5ZuAbtiZPHXcyk9&amp;#43;i47VEZet/N1z585dU&amp;#43;94P7/ntxunAo6oTdrEjXedarxwojdOTVCT2Hrtgwbt3JTXCt8g5nBo7YvH5hRUA0F9HVIvEBlNIt&amp;#43;QOuVLUwIvQCZa7jQ5iSXkK65OvOrOnAdSorFAfuKyrXg4UK/b3j/&amp;#43;ryVqCyyRfG4hKJ&amp;#43;T4CqTTPQqJd73W6R83lj&amp;#43;5gi1tWEkH8I21JwW5L8NNnqdFpVvCZPPXvVLZm4WXCWRiZ6qb77P1SDkhi8rdYx6XmEmH8zWGnndwvhbx4gtalY&amp;#43;e09hm7Tu9OjLXgbgukAllqfUT5BZZisv6A2fIDeeTOWD2FryLanvkFsNTdp8ZRxKr834vSjyCMab/CoFPHHiEnMj6qde32c/2D3yAHo6lv/CMcsaO/ocFLsY3i8dq8OIba05cRlSQTvO3XpUBNduY&amp;#43;o58rI0vA4Wr0REoh10y7nvF37wLlQy&amp;#43;QouXx10rA4hmx0OINVPX/zTn6GnaE3a/OQWwd8j3IeLLMjL2D3qhulYHUK2BuYq8AB8syEfOnT0EPYqPABTfV&amp;#43;sWB1CtgacaXjHgR95e4iHPzz1HtR/xZGPjNUhZAth5z77y&amp;#43;ldaLxPUT6nMJyfXYAyxcvHxOoQsoVYUmfn4eEzzdq3gjl2YtQ&amp;#43;OlaHkC2Ejaan2ngxxGm8ZKwOIRuHTL5EyORLhEy&amp;#43;RMjkS4RMvkTI5EuETL5EyORLhEy&amp;#43;RMjkSwROPsZmJnWv0XgC5YN3aWmbmdi9xiBfORzZBxfE6hCycWht1l&amp;#43;EDHC0zUzsXrNog1rZz8vNe6/i32BidRixxTeo3bxH7TZzNjOhe81iDGppN974BjW672NsZlL3WjyDGnjDYoMayOY/YfN&amp;#43;dO4zd8ugRtvMLKl7LZ5BDbjhBAY1SL5aQXkfuzOdToJuGdQYm5nUvRbToAbVF7lBDWIrL6vz/o&amp;#43;OJ&amp;#43;EigxouH2Yzk7rX4hnUwBsWG9Qwj4vXh4xFPGhdNajRNjNL6l4bGINakP/89UhhdNWgRtvMLKl7bWAMalbN60Vvt3mAumlQo21mltS9NjgGNaey9bNRLaVbBjXaZmZJ3WuDY1BzKgp4Y6FrBjXSgyZ2rw2OQc2ZhhqnwKCGXJb0oEnda3WD2s5rN2xwRUQ23lA9OlYHWvuC3OcePLIog9rO7vHqLnQrvD2S8qCRYA1qD95esH8OTUFiLNroWB0YWziny306emYMGuTqBrW7hbMu2Ammut/nXjrzEGoacda8ZKwOhi33&amp;#43;Kz7VyJ9bKv4AdRLpSpf/vovfimzCDGxOrgtg9unP6OG2PkLbw2cRcgbgeGBOdaOCxWrg2MbIpdB3hRiHBzu05VvDD64IZZ8VKwOjs39G/m2dPExPM9Kt/F&amp;#43;AOc5VuOlYnVw8n1MTEM91JCOsSXf434f4uL86tfImUVBXuC30OLFWlb1tSaC6Q3JZu39nTy&amp;#43;aW3iDjK7XWpsZuUnybVxDwBb/X2UN7eY7XUm1t8SbCKYAtOb9eArDhFOcM7n4400reEYurBZv7PRRFj7sue88WN1ZPIZxHrN8VwTQcPM5DOI9ffp2vu&amp;#43;TD6D2GCx2kDQ7WfyGcTqyOQziNWRyWcQqyOTzyBWRyafQayOTD6DWB2DaI&amp;#43;UeydpPDXyJTiij/JOMnhq5EtwRB/lnfRBuA7Tli&amp;#43;&amp;#43;PZKWL9ERfbgFwQflOkxbvr7YI&amp;#43;XeSc51SMiHGBo7YoG8wPLBbsu&amp;#43;2CPl3knOdYjLhxkaO2KBvEBsmNuyL/ZIuXeScx0StQ8xNHbEAnmBax/sthTYI8EXE5Ic0UfKR7sOqRcTNEMjFKsDYdPclob2SPrFhARH9FmkfLTrkHoxQTM0QrE6EDbNbWloj6RfTEhwRJ9Fyke7DqmRVzc0ArFAXmA23W3ZN3uk3DvJuQ4p&amp;#43;WBDY0cskBdk4gK6Lftij5R7JznXIS0fZGjsiNWByQe6Lftjj5R7JxnXISkfaGjsiNWBywe4LftkjxR7Jxuuw42NDSiZrn0hpR8LXdm08YbqFRvPgwPo9kjkYgntkVLvZOg6zF//B/zHXchFW30WVvrwN6A7X7Zoq038U0Eul7o9ErtYqvt9OzfcfyHmXX7Nu2F/1EWD2s7xh5TLBbtYutulzudyhxXmiRJuGSzRd48ZsNKUr4wUaSz59hE7o0w&amp;#43;d4tKRS&amp;#43;Wqnx76rT7byghhnxr6re/&amp;#43;wQa10XyzW2q83fxERa9WKryrVRfmgEnITHkWyke/B78i4ki&amp;#43;ewjd98Fj3ZlLhbdMgAPHk4F1MHDsWJ1CNk4JDt4uEd4guQ7msmXAJl8iZDJlwiZfInQkg8&amp;#43;6z0VhGfWS08RguXr0SlCR8lThNJB2qcIxQe9WZ8S0n5MHh/NP8A1UI33yen7smlzEmQjbyJw8sn9fezxh7j9j5OvePAH9PlXcvkodpQWvqzc38cdf0jZ/2j5ig8LCn9UmVQ&amp;#43;mh2lhS8r9/dxxx9S9j9avvwn7033Tj6aHaUFLyv397HmP/IpOtN4c1O9k49mR2nBy8r9faz57/9BPrm/jzX/kfa/abl8QayOVOST&amp;#43;/tY89/TVvu66&amp;#43;9jzX&amp;#43;8fPgiXyJf/C0DkXzli8CNyv19rPmPkq88628Z4E4g6gaDWB0Emwm7RtvcMpgC5JP7&amp;#43;1jzHyWfMz0cdYlpoG4wiIUuFvsAbhP5Sk17WemSHiT397HmP0q&amp;#43;mh/lFtBQ6gZr8BUJNhP2DhRXm/PafcAjI/f3seY/yv4XZGVudgub85RHcFroNiySzYQdZwWLTe7vY8x/lP3P3vYbgn0fXbG4BbQnC2OBz3E2A/ZORDSbm4UOtZT7&amp;#43;8hE0v5XL9N95C6K7/uRf4TVQGsZxmbErpO2qvpJ8DBgub9PfHDiUrjScwv0Xy2lYnWI2BiURyKuP3em36dYwchN1V&amp;#43;l2KbeJmNidQjYOKy1ldX2Idwl00c0K5CgPNHK14vaUW4vK2d6EB62zW02W0SJtGXTsTqM2Tisd5RV5&amp;#43;9pwN6OvlBGHzJMxeowZeNwdaZzN2kfO0W4b/CmM5HlgTN5weCO22N1mLFxuFrQ16MHapg6krvnqC6397/Vt0dj98edscA3DNg4eEoBs9bqf0R/nKlbuPxOR57sg6245anF6jBgY&amp;#43;D8l3oKliFDhicD/wMO9/PoWHndrwAAAABJRU5ErkJggg==&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Without the fourth column and the bottom 1 value a translation wouldn&amp;rsquo;t have been possible.&lt;/p&gt;
&lt;h3 id=&#34;scale&#34;&gt;Scale
&lt;/h3&gt;&lt;p&gt;A scale transformation scales each of a vector&amp;rsquo;s components by a (different) scalar. It is commonly used to shrink or stretch a vector as demonstrated below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://open.gl/media/img/c4_scaling.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTCF4GRkX9DB7BYe3BNF_2iEchNnVEuvT-qLQ&amp;amp;usqp=CAU&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;rotation&#34;&gt;Rotation
&lt;/h3&gt;&lt;p&gt;Objects can be rotated around any given axis, but for now only the X, Y and Z axis are important. You&amp;rsquo;ll see later in this chapter that any rotation axis can be established by rotating around the X, Y and Z axis simultaneously.&lt;/p&gt;
&lt;p&gt;The matrices for rotating around the three axes are specified here. The rotation angle is indicated by the theta (θ
&lt;img src=&#34;https://open.gl/media/img/c4_rotation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.stack.imgur.com/spoba.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;To prove these matrices, we will use basic linear algebra and trig identities illustrated below, for simplicity we will prove the rotation around z-axis because it&amp;rsquo;s the easiest.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.discordapp.com/attachments/956925681059647558/1204505838157566043/IMG_20240206_211344.jpg?ex=65d4fa7a&amp;amp;is=65c2857a&amp;amp;hm=4d26f8dd261b808bb49b34572592c0051210e71739807dd1d50adabb81286afe&amp;amp;&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;coordinates-in-opengl&#34;&gt;Coordinates in OpenGL
&lt;/h3&gt;&lt;p&gt;All vertices we render initially rendered in a local space (Object Coordinates) that are between [-1.0,1.0], or &lt;strong&gt;NDC&lt;/strong&gt; (&lt;strong&gt;Normalized Device Coordinate&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;But as you may notice that space isn&amp;rsquo;t enough for us to make a game or anything, we need to scale down the objects, move them around and rotate them, all of that can be done using a &lt;strong&gt;Model Matrix&lt;/strong&gt; in a &lt;strong&gt;World space&lt;/strong&gt;, which is relatively a bigger space.&lt;/p&gt;
&lt;p&gt;and since we don&amp;rsquo;t have much freedom with our rendered objects, we need some sort of a camera to view them from different angles that&amp;rsquo;s where we create our &lt;strong&gt;View Matrix&lt;/strong&gt; and that&amp;rsquo;s we call &lt;strong&gt;View space ( eye coordinates)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://open.gl/media/img/c4_transformation.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Finally we need to create a feel of dimensions, where far objects appear smaller than closer objects. That&amp;rsquo;s where we use &lt;strong&gt;Projection Matrix&lt;/strong&gt;, but it&amp;rsquo;s a little complicated so let&amp;rsquo;s first define what a ** View Frustum** is.&lt;/p&gt;
&lt;h4 id=&#34;view-frustum--orthographic-projection-&#34;&gt;View Frustum ( Orthographic Projection )
&lt;/h4&gt;&lt;p&gt;An orthographic projection matrix defines a cube-like frustum box that defines the clipping space where each vertex outside this box is clipped. When creating an orthographic projection matrix we specify the width, height and length of the visible frustum. All the coordinates inside this frustum will end up within the NDC range after transformed by its matrix and thus won&amp;rsquo;t be clipped.&lt;/p&gt;
&lt;p&gt;so simply, any object in the colored range will be visible, but won&amp;rsquo;t be so realistic since it doesn&amp;rsquo;t take perspective into account.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://learnwebgl.brown37.net/_images/viewing_frustum.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;view-frustum--perspective-projection-&#34;&gt;View Frustum ( Perspective Projection )
&lt;/h4&gt;&lt;p&gt;perspective projection tries to mimic and it does so using a perspective projection matrix. The projection matrix maps a given frustum range to clip space, but also manipulates the w value of each vertex coordinate in such a way that the further away a vertex coordinate is from the viewer, the higher this w component becomes.&lt;/p&gt;
&lt;p&gt;It also takes FOV into consideration, the bigger FOV, the smaller objects will look, since we are rendering a bigger chunk of space, so objects will looks smaller.&lt;/p&gt;
&lt;p&gt;To transform the clipping coordinate into a normalized device coordinate, perspective division has to be performed. A clipping coordinate resulting from a perspective projection has a number different than 1 in the fourth row, also known as w. This number directly reflects the effect of objects further away being smaller than those up front using &lt;strong&gt;Z-Depth testing&lt;/strong&gt; and it&amp;rsquo;s also some algorithm that rasteraizor use im not really interested in that atm.
&lt;img src=&#34;https://learnwebgl.brown37.net/_images/side_view_frustum.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://i.stack.imgur.com/1qkwc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
a lot of math is going behind the scene that my brain won&amp;rsquo;t handle, but if you are some math guru, here &lt;a class=&#34;link&#34; href=&#34;https://www.songho.ca/opengl/gl_projectionmatrix.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.songho.ca/opengl/gl_projectionmatrix.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;cameraview-space&#34;&gt;Camera/View space
&lt;/h3&gt;&lt;p&gt;When we&amp;rsquo;re talking about camera/view space we&amp;rsquo;re talking about all the vertex coordinates as seen from the camera&amp;rsquo;s perspective as the origin of the scene: the view matrix transforms all the world coordinates into view coordinates that are relative to the camera&amp;rsquo;s position and direction.&lt;/p&gt;
&lt;p&gt;To define a camera we need its position in world space, the direction it&amp;rsquo;s looking at (x), a vector pointing to the right(z) and a vector pointing upwards(Y) from the camera. A careful reader may notice that we&amp;rsquo;re actually going to create a coordinate system with 3 perpendicular unit axes with the camera&amp;rsquo;s position as the origin.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://learnopengl.com/img/getting-started/camera_axes.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;In Practice
Guest Articles
Code repository
Translations
Privacy
About&lt;/p&gt;
&lt;p&gt;Camera
In the previous chapter we discussed the view matrix and how we can use the view matrix to move around the scene (we moved backwards a little). OpenGL by itself is not familiar with the concept of a camera, but we can try to simulate one by moving all objects in the scene in the reverse direction, giving the illusion that we are moving.&lt;/p&gt;
&lt;p&gt;In this chapter we&amp;rsquo;ll discuss how we can set up a camera in OpenGL. We will discuss a fly style camera that allows you to freely move around in a 3D scene. We&amp;rsquo;ll also discuss keyboard and mouse input and finish with a custom camera class.&lt;/p&gt;
&lt;p&gt;Camera/View space
When we&amp;rsquo;re talking about camera/view space we&amp;rsquo;re talking about all the vertex coordinates as seen from the camera&amp;rsquo;s perspective as the origin of the scene: the view matrix transforms all the world coordinates into view coordinates that are relative to the camera&amp;rsquo;s position and direction. To define a camera we need its position in world space, the direction it&amp;rsquo;s looking at, a vector pointing to the right and a vector pointing upwards from the camera. A careful reader may notice that we&amp;rsquo;re actually going to create a coordinate system with 3 perpendicular unit axes with the camera&amp;rsquo;s position as the origin.&lt;/p&gt;
&lt;h4 id=&#34;1--camera-position&#34;&gt;1- Camera position
&lt;/h4&gt;&lt;p&gt;Getting the camera position is easy. The camera position is a vector in world space that points to the camera&amp;rsquo;s position. We set the camera at the same position we&amp;rsquo;ve set the camera in the previous chapter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vec3 cameraPos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vec3&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3.0f&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Don&amp;rsquo;t forget that the positive z-axis is going through your screen towards you so if we want the camera to move backwards, we move along the positive z-axis.&lt;/p&gt;
&lt;h4 id=&#34;2--camera-direction&#34;&gt;2- Camera direction
&lt;/h4&gt;&lt;p&gt;The next vector required is the camera&amp;rsquo;s direction e.g. at what direction it is pointing at. For now we let the camera point to the origin of our scene: (0,0,0).&lt;/p&gt;
&lt;p&gt;Remember that if we subtract two vectors from each other we get a vector that&amp;rsquo;s the difference of these two vectors? Subtracting the camera position vector from the scene&amp;rsquo;s origin vector thus results in the direction vector we want.&lt;/p&gt;
&lt;p&gt;For the view matrix&amp;rsquo;s coordinate system we want its z-axis to be positive and because by convention (in OpenGL) the camera points towards the negative z-axis we want to negate the direction vector. If we switch the subtraction order around we now get a vector pointing towards the camera&amp;rsquo;s positive z-axis&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vec3 cameraTarget &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vec3&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vec3 cameraDirection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;normalize&lt;/span&gt;(cameraPos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; cameraTarget);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3--right-axis&#34;&gt;3- Right axis
&lt;/h4&gt;&lt;p&gt;The next vector that we need is a right vector that represents the positive x-axis of the camera space. To get the right vector we use a little trick by first specifying an up vector that points upwards (in world space). Then we do a cross product on the up vector and the direction vector from step 2. Since the result of a cross product is a vector perpendicular to both vectors, we will get a vector that points in the positive x-axis&amp;rsquo;s direction (if we would switch the cross product order we&amp;rsquo;d get a vector that points in the negative x-axis):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vec3 up &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vec3&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;); 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vec3 cameraRight &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;normalize&lt;/span&gt;(glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cross&lt;/span&gt;(up, cameraDirection));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;4--up-axis&#34;&gt;4- Up axis
&lt;/h4&gt;&lt;p&gt;is just the cross product between right and camera direction again&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vec3 cameraUp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;cross&lt;/span&gt;(cameraDirection, cameraRight);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;5--look-at-function&#34;&gt;5- Look at function
&lt;/h4&gt;&lt;p&gt;The glm::LookAt function requires a position, target and up vector respectively. This example creates a view matrix that is the same as the one we created in the previous chapter.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;mat4 view;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;view &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lookAt&lt;/span&gt;(glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vec3&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3.0f&lt;/span&gt;), 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  		   glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vec3&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;), 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  		   glm&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vec3&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>But what are vertex buffers</title>
        <link>http://localhost:1313/computer-graphics---opengl/p2---vertex-buffers/</link>
        <pubDate>Sun, 21 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p2---vertex-buffers/</guid>
        <description>&lt;p&gt;&amp;mdash;### Vertex Buffers and Drawing a Triangle&lt;/p&gt;
&lt;p&gt;as we finally are set up, we can start learning OpenGL and make things happen.&lt;/p&gt;
&lt;p&gt;to start with drawing a triangle in &lt;strong&gt;&amp;ldquo;Moden OpenGL&amp;rdquo;&lt;/strong&gt; we need two things, a &lt;strong&gt;vertex buffer&lt;/strong&gt; and a &lt;strong&gt;Shader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a buffer is nothing but an array, the basic concept that i want to define a bunch of data that represents a triangle, put it in our GPU&amp;rsquo;s vRam, and then define a draw function, and then tell our GPU how to read those data, and display it on screen.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Have some data, draw me something&amp;rdquo; or &amp;quot; I want you to select this buffer, and this shader, then draw me a triangle&amp;quot; it&amp;rsquo;s a &lt;strong&gt;state machine&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; positions[&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt; }; &lt;span style=&#34;color:#75715e&#34;&gt;// our data to draw a triangle also a buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Creating our Vertex Buffer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; buffer;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glGenBuffers&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;buffer); &lt;span style=&#34;color:#75715e&#34;&gt;// Generates a buffer and gives back ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Binding a buffer (selecting)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glBindBuffer&lt;/span&gt;(GL_ARRAY_BUFFER, buffer); &lt;span style=&#34;color:#75715e&#34;&gt;// binding to the buffer we created.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Put data into the Buffer.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glBufferData&lt;/span&gt;(GL_ARRAY_BUFFER, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt;), positions,GL_STATIC_DRAW);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Now we need to tell OpenGL how our data is laid out, is it a 2D Vector or 3D...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// But it&amp;#39;s a problem for future me.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Positions Array:&lt;/strong&gt; This array holds the vertex coordinates of your triangle. Each vertex has two coordinates (x, y), and you have three vertices, making a total of six values.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Generate and Bind Vertex Buffer:&lt;/strong&gt; &lt;code&gt;glGenBuffers&lt;/code&gt; is used to create a buffer (in this case, a vertex buffer) and allocate an ID for it. &lt;code&gt;glBindBuffer&lt;/code&gt; is used to bind the buffer, making it the active buffer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Buffer Data:&lt;/strong&gt; &lt;code&gt;glBufferData&lt;/code&gt; is used to allocate and initialize the data store of the buffer. In this case, it copies the vertex data from the positions array into the buffer. The &lt;code&gt;GL_STATIC_DRAW&lt;/code&gt; hint indicates that the data is not expected to change frequently.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can refer to the documentation to know more info about it &lt;a class=&#34;link&#34; href=&#34;https://docs.gl/gl4/glBufferData&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.gl/gl4/glBufferData&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Vertex Layout (Not Implemented Yet):&lt;/strong&gt; The code comments mention that it&amp;rsquo;s a task for the future to inform OpenGL about the layout of the data. This typically involves specifying the format of the vertex data, like whether it represents 2D or 3D coordinates and how they are packed in memory.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Getting Started with OpenGL</title>
        <link>http://localhost:1313/computer-graphics---opengl/p1---getting-started/</link>
        <pubDate>Sun, 21 Jan 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/computer-graphics---opengl/p1---getting-started/</guid>
        <description>&lt;p&gt;Welcome to my &lt;strong&gt;OpenGL&lt;/strong&gt; adventure! 🚀 In this blog series, I&amp;rsquo;ll be sharing my journey in world of &lt;strong&gt;OpenGL&lt;/strong&gt; , starting from scratch and following &lt;strong&gt;Cherno&amp;rsquo;s&lt;/strong&gt; playlist and this site &lt;a class=&#34;link&#34; href=&#34;https://learnopengl.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learnopengl.com/&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;it might take some time to master these concepts, but I&amp;rsquo;m committed to giving it my all.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenGL&lt;/strong&gt;, or &lt;strong&gt;Open Graphics Library,&lt;/strong&gt; is a powerful and cross-platform API (Application Programming Interface) used for rendering &lt;strong&gt;2D&lt;/strong&gt; and &lt;strong&gt;3D&lt;/strong&gt; graphics. It&amp;rsquo;s widely employed in various fields, including video game development, simulations, virtual reality, and computer-aided design.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The first thing we need to do before we start creating stunning graphics is to create an OpenGL context and an application window to draw in. However, those operations are specific per operating system and OpenGL purposefully tries to abstract itself from these operations. This means we have to create a window, define a context, and handle user input all by ourselves.&lt;/p&gt;
&lt;p&gt;so for doing that we will use the &lt;a class=&#34;link&#34; href=&#34;https://www.glfw.org/download&#34;  title=&#34;GLFW&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GLFW&lt;/a&gt; 32-bit Binaries&lt;/p&gt;
&lt;p&gt;for simplicity, we will build using visual studio, all we need to do to get started is the &lt;code&gt;glfw3.lib&lt;/code&gt; and &lt;code&gt;glfw3.h&lt;/code&gt; header.&lt;/p&gt;
&lt;p&gt;so, after creating our project in visual studio we can start editing the configuration so the program knows where our headers are.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/JzdZMhZx/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;after including our headers directory, next we need to tell the linker where our static library is.
&lt;code&gt;${SolutionDir}&lt;/code&gt; &lt;strong&gt;is a macro for where our .sln file is.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/9Xp4cMj9/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Next we need to add the dependencies to the linker. Initially we only need to add the &lt;code&gt;glfw3.lib&lt;/code&gt; but that raises a lot of errors because some more static libs are needed for the code to compile correctly, after resolving all the errors here are all the dependencies i needed to run the code &amp;ldquo;It should all be pre-installed in your device&amp;rdquo;
&lt;code&gt;glfw3.lib;opengl32.lib;User32.lib;Gdi32.lib;Shell32.lib&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/3wKV5njm/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;doing that , we are good to go to start creating our first triangle.
Here is the code we used to do so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;GLFW/glfw3.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    GLFWwindow&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; window;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize the library */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glfwInit&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Create a windowed mode window and its OpenGL context */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    window &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;glfwCreateWindow&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;640&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;480&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;, NULL, NULL);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;window)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glfwTerminate&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Make the window&amp;#39;s context current */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glfwMakeContextCurrent&lt;/span&gt;(window);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Loop until the user closes the window */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;glfwWindowShouldClose&lt;/span&gt;(window))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* Render here */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glClear&lt;/span&gt;(GL_COLOR_BUFFER_BIT);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glBegin&lt;/span&gt;(GL_TRIANGLES);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glVertex2f&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glVertex2f&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0f&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glVertex2f&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5f&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glEnd&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* Swap front and back buffers */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glfwSwapBuffers&lt;/span&gt;(window);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* Poll for and process events */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;glfwPollEvents&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;glfwTerminate&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/K8KrKLZw/image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;It&amp;rsquo;s very straight forward and easy to understand, we don&amp;rsquo;t need to know more than that for now, if it compiles, we succeeded to use the Legacy openGL in our project, but next we need to install the Modern OpenGL to keep going.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Monolithic Software</title>
        <link>http://localhost:1313/post/monolithic-software/</link>
        <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/monolithic-software/</guid>
        <description>&lt;img src="http://localhost:1313/post/monolithic-software/ms.png" alt="Featured image of post Monolithic Software" /&gt;&lt;h3 id=&#34;what-is-meant-by-monolithic-architecture&#34;&gt;What is meant by monolithic architecture?
&lt;/h3&gt;&lt;p&gt;Monolithic architecture refers to a traditional software development model where all functions of an application are integrated into a single, tightly coupled codebase. This approach enables the handling of multiple related tasks within one unified system, but it also leads to challenges, as modifications in one area can significantly impact the entire codebase. In contrast to modular alternatives like microservices, which break down applications into independent components that can be developed, deployed, and scaled individually, monolithic architecture can be restrictive and time-consuming to update.&lt;/p&gt;
&lt;h3 id=&#34;lets-discover-different-aspects-of-monolithic-architecture&#34;&gt;Let’s discover different aspects of monolithic architecture:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Deployment&lt;/strong&gt;: Developers install the entire application code base and dependencies in a single environment, so it’s easier in comparison to alternatives like microservices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Development&lt;/strong&gt;: Starting a monolithic application is simpler since it requires less upfront planning. You can begin and continue to add code modules as required. Over time, though, the application may get complicated and difficult to update or modify.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Scaling&lt;/strong&gt;: As they scale, monolithic apps encounter a number of difficulties. The entire program must be scaled as needs change because the monolithic architecture houses all functionalities in a single code base.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;but-when-is-building-monolithic-software-preferable&#34;&gt;But when is building monolithic software preferable?
&lt;/h3&gt;&lt;p&gt;There are instances where using a monolithic architecture may be more beneficial than microservices. For example, Twilio&amp;rsquo;s Segment transitioned from a microservices approach to a monolithic one due to the complexities that microservices introduced, such as increased operational overhead, challenges in debugging, and the need for greater coordination among teams.&lt;/p&gt;
&lt;p&gt;Similarly, Amazon Prime Video initially implemented distributed components for its audio and video quality monitoring but found it too costly to maintain at scale. They ultimately decided to consolidate these components into a single monolithic application. These cases illustrate that a simpler, monolithic architecture can facilitate faster development cycles and reduce overhead.&lt;/p&gt;
&lt;h3 id=&#34;in-conclusion-monolithic-software-should-be-considered-when&#34;&gt;In conclusion, monolithic software should be considered when:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Project Simplicity&lt;/strong&gt;: The application is small and straightforward, requiring limited functionality.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rapid Development Needs&lt;/strong&gt;: There’s a need for quick delivery of a functional product without the complexities of managing multiple services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Limited Team Size&lt;/strong&gt;: The development team is small, making it easier to manage a single codebase rather than coordinating across multiple services.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Low Scalability Requirements&lt;/strong&gt;: The application is not expected to grow significantly, making the overhead of a microservices architecture unnecessary.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unified Deployment&lt;/strong&gt;: Components are tightly integrated and need to be deployed together, simplifying the deployment process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;most-common-architecture-styles-for-monolithic-software&#34;&gt;Most Common Architecture Styles for Monolithic Software:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layered Pattern&lt;/strong&gt;: This divides the monolith into logical layers, typically including a presentation layer (UI), a business layer (business logic), and a data layer (database operations).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Model-View-Controller (MVC)&lt;/strong&gt;: Common in web applications, MVC separates the application into three components: the model (data), the view (user interface), and the controller (handles input and updates).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pipe and Filter&lt;/strong&gt;: This pattern structures systems that process data streams, with each processing step encapsulated in a filter and connected by pipes for buffering or synchronization.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Client-Server&lt;/strong&gt;: In this architecture, the system is split into a server (providing services) and a client (accessing those services), often running on the same machine and communicating through function calls.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Blackboard&lt;/strong&gt;: This pattern addresses complex problems by allowing multiple specialized subsystems to contribute their knowledge to a central component (the blackboard), which contains structured information from the problem domain.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;advantages-of-monolithic-software&#34;&gt;Advantages of Monolithic Software:
&lt;/h3&gt;&lt;p&gt;Monolithic architecture offers several advantages, starting with its simplicity in development. It follows a standard approach, requiring no additional knowledge, as all source code is centralized in one location, making it easy to understand. Debugging is straightforward since all code is contained within a single unit, allowing for a clear trace of requests and issues. Testing is also simplified, as only one service needs to be tested without external dependencies. Deployment is efficient, involving just one unit, such as a jar file, and eliminating concerns about breaking changes when the UI is integrated with backend code.&lt;/p&gt;
&lt;p&gt;Moreover, the evolution of the application is seamless since there are no limitations from a business logic standpoint; necessary data for new features is already available. Cross-cutting concerns, such as security and logging, need to be addressed only once, streamlining the development process. Onboarding new team members becomes easier as the codebase is consolidated, enabling them to quickly debug and familiarize themselves with the application. Finally, during the early stages, the low cost of maintaining a single deployment unit minimizes infrastructure and development expenses, making it an attractive option for startups and small projects.&lt;/p&gt;
&lt;h3 id=&#34;references&#34;&gt;References:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/compare/the-difference-between-monolithic-and-microservices-architecture/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AWS: Monolithic vs Microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.akamai.com/blog/cloud/monolith-versus-microservices-weigh-the-difference&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Akamai: Monolith Versus Microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.designgurus.io/blog/monolithic-service-oriented-microservice-architecture&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Design Gurus: Monolithic vs Microservice Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://datamify.medium.com/monolithic-architecture-advantages-and-disadvantages-e71a603eec89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Datamify: Monolithic Architecture Advantages and Disadvantages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Archives</title>
        <link>http://localhost:1313/page/archives/</link>
        <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/page/archives/</guid>
        <description></description>
        </item>
        <item>
        <title>Links</title>
        <link>http://localhost:1313/page/links/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/page/links/</guid>
        <description>&lt;p&gt;Below, you’ll find direct links to my profiles and projects. Click through to see what I’ve been working on and to stay updated!&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Search</title>
        <link>http://localhost:1313/page/search/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/page/search/</guid>
        <description></description>
        </item>
        
    </channel>
</rss>
