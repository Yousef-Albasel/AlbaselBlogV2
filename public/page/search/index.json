[{"content":"What is meant by monolithic architecture?\rMonolithic architecture refers to a traditional software development model where all functions of an application are integrated into a single, tightly coupled codebase. This approach enables the handling of multiple related tasks within one unified system, but it also leads to challenges, as modifications in one area can significantly impact the entire codebase. In contrast to modular alternatives like microservices, which break down applications into independent components that can be developed, deployed, and scaled individually, monolithic architecture can be restrictive and time-consuming to update.\nLet’s discover different aspects of monolithic architecture:\rDeployment: Developers install the entire application code base and dependencies in a single environment, so it’s easier in comparison to alternatives like microservices.\nDevelopment: Starting a monolithic application is simpler since it requires less upfront planning. You can begin and continue to add code modules as required. Over time, though, the application may get complicated and difficult to update or modify.\nScaling: As they scale, monolithic apps encounter a number of difficulties. The entire program must be scaled as needs change because the monolithic architecture houses all functionalities in a single code base.\nBut when is building monolithic software preferable?\rThere are instances where using a monolithic architecture may be more beneficial than microservices. For example, Twilio\u0026rsquo;s Segment transitioned from a microservices approach to a monolithic one due to the complexities that microservices introduced, such as increased operational overhead, challenges in debugging, and the need for greater coordination among teams.\nSimilarly, Amazon Prime Video initially implemented distributed components for its audio and video quality monitoring but found it too costly to maintain at scale. They ultimately decided to consolidate these components into a single monolithic application. These cases illustrate that a simpler, monolithic architecture can facilitate faster development cycles and reduce overhead.\nIn conclusion, monolithic software should be considered when:\rProject Simplicity: The application is small and straightforward, requiring limited functionality. Rapid Development Needs: There’s a need for quick delivery of a functional product without the complexities of managing multiple services. Limited Team Size: The development team is small, making it easier to manage a single codebase rather than coordinating across multiple services. Low Scalability Requirements: The application is not expected to grow significantly, making the overhead of a microservices architecture unnecessary. Unified Deployment: Components are tightly integrated and need to be deployed together, simplifying the deployment process. Most Common Architecture Styles for Monolithic Software:\rLayered Pattern: This divides the monolith into logical layers, typically including a presentation layer (UI), a business layer (business logic), and a data layer (database operations).\nModel-View-Controller (MVC): Common in web applications, MVC separates the application into three components: the model (data), the view (user interface), and the controller (handles input and updates).\nPipe and Filter: This pattern structures systems that process data streams, with each processing step encapsulated in a filter and connected by pipes for buffering or synchronization.\nClient-Server: In this architecture, the system is split into a server (providing services) and a client (accessing those services), often running on the same machine and communicating through function calls.\nBlackboard: This pattern addresses complex problems by allowing multiple specialized subsystems to contribute their knowledge to a central component (the blackboard), which contains structured information from the problem domain.\nAdvantages of Monolithic Software:\rMonolithic architecture offers several advantages, starting with its simplicity in development. It follows a standard approach, requiring no additional knowledge, as all source code is centralized in one location, making it easy to understand. Debugging is straightforward since all code is contained within a single unit, allowing for a clear trace of requests and issues. Testing is also simplified, as only one service needs to be tested without external dependencies. Deployment is efficient, involving just one unit, such as a jar file, and eliminating concerns about breaking changes when the UI is integrated with backend code.\nMoreover, the evolution of the application is seamless since there are no limitations from a business logic standpoint; necessary data for new features is already available. Cross-cutting concerns, such as security and logging, need to be addressed only once, streamlining the development process. Onboarding new team members becomes easier as the codebase is consolidated, enabling them to quickly debug and familiarize themselves with the application. Finally, during the early stages, the low cost of maintaining a single deployment unit minimizes infrastructure and development expenses, making it an attractive option for startups and small projects.\nReferences:\rAWS: Monolithic vs Microservices Akamai: Monolith Versus Microservices Design Gurus: Monolithic vs Microservice Architecture Datamify: Monolithic Architecture Advantages and Disadvantages ","date":"2023-11-03T00:00:00Z","image":"http://localhost:1313/post/monolithic-software/ms_hu7543870176958537489.png","permalink":"http://localhost:1313/post/monolithic-software/","title":"Monolithic Software"},{"content":"Java Multithreading Notes\rThese are course notes taken from Rayan Slim Multithreading playlist, which is really good and worth the watch.\nMultithreading in Java is a process of executing multiple threads simultaneously.\nA thread is a lightweight sub-process, the smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.\nIn Java, a thread always exists in any one of the following states. These states are:\nNew Active Blocked / Waiting Timed Waiting Terminated Explanation of Different Thread States\rNew: Whenever a new thread is created, it is always in the new state. For a thread in the new state, the code has not been run yet and thus has not begun its execution.\nActive: When a thread invokes the start() method, it moves from the new state to the active state. The active state contains two states within it: one is runnable, and the other is running.\nBlocked or Waiting: Whenever a thread is inactive for a span of time (not permanently) then, either the thread is in the blocked state or is in the waiting state.\nTerminated: A thread reaches the termination state because of the following reasons:\nWhen a thread has finished its job, then it exists or terminates normally. Abnormal termination: It occurs when some unusual events such as an unhandled exception or segmentation fault. Creating a Thread\rpublic static class ChildThreadTask implements Runnable{ @Override public void run(){ count(); }} This class is used to create a thread that executes the count() method when started.\nOr we can use lambda expression\nThread T1 = new Thread( () -\u0026gt; {count();}); Setting Priority\rWhen giving max priority, it doesn\u0026rsquo;t mean it will be the first to run, but we can gurantee it finishes first\nT2.setPriority(Thread.MAX_PRIORITY); To make other threads surrender or give away thier turn in running we can use Yeild()\nThread.yield() in Java is a static method that signals to the thread scheduler that the current thread is willing to pause its execution and allow other threads of the same or higher priority to run. However, there are important details to understand about what yield() does and doesn\u0026rsquo;t do:\nExample\rNow having these three threads: Thread - 0, Thread - 1 and Thread - 2 First two are of the same priority\nThread T1 = new Thread( () -\u0026gt; {count();}); Thread T2 = new Thread( () -\u0026gt; {count();}); Thread T3 = new Thread( () -\u0026gt; {count();}); T1.setPriority(Thread.MAX_PRIORITY); T1.start(); T2.setPriority(Thread.MAX_PRIORITY); T2.start(); We also have a count method that will run when a thread starts, printing some information, and a yield method.\npublic static void count(){ for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;Current Thread: \u0026#34; + Thread.currentThread().getName() + \u0026#34; It\u0026#39;s state is \u0026#34; + Thread.currentThread().getState() + \u0026#34; With Prioirty \u0026#34; + Thread.currentThread().getPriority() + \u0026#34; Counting - \u0026#34; + i); if (!Thread.currentThread().getName().equals(\u0026#34;Thread-2\u0026#34;)) { Thread.yield(); } } } The expected output for this code, Both threads with the highest priority will be executed at some turn, then they will alternate execution due to yield, and continue running until they finish, Thread-2 will not get affected by Yeild since it\u0026rsquo;s out the condition.\nCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 81\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 80\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 82\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 81\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 83\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 82\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 84\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 83\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 81\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 80\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 82\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 81\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 83\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 82\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 84\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 83\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 85\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 84\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 86\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 85\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 87\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 86\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 88\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 87\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 89\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 88\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 90\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 91\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 89\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 92\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 90\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 3\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 93\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 91\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 4\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 94\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 92\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 95\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 5\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 93\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 96\rCurrent Thread: main It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 4\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 6\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 94\rCurrent Thread: main It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 5\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 95\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 97\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 7\rCurrent Thread: main It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 6\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 96\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 98\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 97\rCurrent Thread: Thread-0 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 99\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 98\rCurrent Thread: Thread-1 It\u0026#39;s state is RUNNABLE With Prioirty 10 Counting - 99 Now that Thread -1 finished, Another Thread starts, doesn\u0026rsquo;t yield though.\nCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 8\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 9\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 10\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 11\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 12\rCurrent Thread: main It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 7\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 13\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 14\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 15\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 16\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 17\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 18\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 19\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 20\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 21\rCurrent Thread: Thread-2 It\u0026#39;s state is RUNNABLE With Prioirty 5 Counting - 22 Thread Inheritance\rIn this section we are trying to be a little more organized and leverage the use of Object Oriented Architecture for managing and creating threads.\nAll we have to do is create a class that extends Thread class, override it\u0026rsquo;s run method and add your own logic\npublic class AtheleteThread extends Thread{ private int bibNumber; public AtheleteThread(int bibNumber) { this.bibNumber = bibNumber; } public int getBibNumber() { return bibNumber; } public void setBibNumber(int bibNumber) { this.bibNumber = bibNumber; } @Override public void run() { double distanceKM = 10; double steps = 0.00000001; for (double i = 0; i \u0026lt;= distanceKM; i += steps) { if (Math.abs(i - distanceKM) \u0026lt; steps) { System.out.println(\u0026#34;\\nAthlete number \u0026#34; + bibNumber + \u0026#34; has finished the race.\\n\u0026#34;); break; } } } } Then all you have to do is\nAtheleteThread firstAthelete = new AtheleteThread(123123); AtheleteThread secondAthelete = new AtheleteThread(999999); firstAthelete.start(); secondAthelete.start(); And that\u0026rsquo;s much cleaner than having to do this\npublic static void main(String[] args) { // Creating the first athlete thread Thread firstAthlete = new Thread(() -\u0026gt; { int bibNumber = 84921; runRace(bibNumber); }); // Creating the second athlete thread Thread secondAthlete = new Thread(() -\u0026gt; { int bibNumber = 43114; runRace(bibNumber); }); // Starting the threads firstAthlete.start(); secondAthlete.start(); } private static void runRace(int bibNumber) { double distanceKM = 10; double steps = 0.00000001; for (double i = 0; i \u0026lt;= distanceKM; i += steps) { if (Math.abs(i - distanceKM) \u0026lt; steps) { System.out.println(\u0026#34;\\nAthlete number \u0026#34; + bibNumber + \u0026#34; has finished the race.\\n\u0026#34;); break; } } } Thread Joinning\rThread joining is a mechanism in Java (and many other programming languages) that allows one thread to wait for the completion of another. It is achieved using the join() method provided by the Thread class.\nHow join() Works:\rWhen threadA.join() is called in the context of another thread (e.g., threadB), threadB will pause its execution and wait until threadA has completed its execution. Once threadA finishes, threadB resumes execution from the point where it called join(). In this example we have 4 Threads, each representing a player doing progress on some game, calculating score, when finished the main threads displays the player with most score.\nPlayerThread[] threads = new PlayerThread[4]; for (int i = 0; i \u0026lt; threads.length; i++) { threads[i] = new PlayerThread(i+1); threads[i].start(); } // TODO: Task One - Wait for all player threads to finish // Determine the player with the highest score int winningScore = 0; int winner = 0; for (int i = 0; i \u0026lt; threads.length; i++) { if (threads[i].getScore() \u0026gt; winningScore) { winningScore = threads[i].getScore(); winner = i + 1; } } System.out.println(\u0026#34;Player \u0026#34; + winner + \u0026#34; wins with a score of \u0026#34; + winningScore); But you can notice that, the main thread finished faster that all 4 threads and this is an issue\nPlayer 1 wins with a score of 504\rPlayer 1 final score: 1349982150\rPlayer 4 final score: 1350016018\rPlayer 3 final score: 1350107767\rPlayer 2 final score: 1350004850 A simple solution is using Join(), by calling it for each player thread, while on the main thread. It will cause the main thread to pause until all player threads finished\nfor (PlayerThread player : threads){ player.join(); } Player 4 final score: 1350028067\rPlayer 2 final score: 1349911192\rPlayer 3 final score: 1349980041\rPlayer 1 wins with a score of 1350029760 Daemon Threads\rDaemon threads are special types of threads in Java that run in the background and do not prevent the program from exiting. The key characteristic of daemon threads is that they do not block the JVM from shutting down when all non-daemon (user) threads have completed. They are designed to perform background tasks, such as monitoring or housekeeping operations.\nBackground Operation: Daemon threads are typically used for tasks that are not crucial to the main execution of the program, like garbage collection, logging, or periodic checks. They work in the background while the main (user) threads are executing.\nJVM Shutdown: The JVM can terminate as soon as all non-daemon threads (user threads) have finished. When there are only daemon threads left, the JVM will exit, even if the daemon threads are still running. This means daemon threads don\u0026rsquo;t prevent the program from exiting, which is different from regular user threads that will cause the program to wait until they finish.\nSetting a Thread as Daemon: You can make a thread a daemon thread by calling the setDaemon(true) method before starting it. This must be done before the thread is started; otherwise, an IllegalThreadStateException will be thrown .\nIn this example we are creating two threads, one which performs a very intensive task, then finishes. other is used for logging\nThread memoryMonitorThread = new Thread(new MemoryMonitorDaemon()); memoryMonitorThread.start(); Thread memoryIntensiveTaskThread = new Thread(new MemoryIntensiveTask()); memoryIntensiveTaskThread.start(); having the code like this, the logging thread will keep executing\npublic class MemoryMonitorDaemon implements Runnable { @Override public void run() { Runtime runtime = Runtime.getRuntime(); while (true) { try { long usedMemory = runtime.totalMemory() - runtime.freeMemory(); System.out.println(\u0026#34;Memory Usage: \u0026#34; + usedMemory + \u0026#34; bytes\u0026#34;); Thread.sleep(5000); // Check memory usage every 5 seconds } catch (InterruptedException e) { System.out.println(\u0026#34;Memory monitor interrupted\u0026#34;); } } } } import java.util.ArrayList; import java.util.Random; public class MemoryIntensiveTask implements Runnable { @Override public void run() { ArrayList\u0026lt;Integer\u0026gt; numbers = new ArrayList\u0026lt;\u0026gt;(); Random random = new Random(); try { for (int i = 0; i \u0026lt; 100000; i++) { // Reduced number of iterations numbers.add(random.nextInt()); if (i % 1000 == 0) { Thread.sleep(150); // Adds a slight delay every 1000 iterations } } } catch (InterruptedException e) { System.out.println(\u0026#34;Memory intensive task was interrupted\u0026#34;); } System.out.println(\u0026#34;Finished generating random numbers\u0026#34;); } } After the intensive task thread finishes we can see that the logging thread still running which makes no sense.\nMemory Usage: 2978040 bytes\rMemory Usage: 4384032 bytes\rMemory Usage: 5255840 bytes\rMemory Usage: 6269928 bytes\rFinished generating random numbers\rMemory Usage: 6269928 bytes Lifecycle: Daemon threads are typically short-lived. Since the JVM doesn\u0026rsquo;t wait for daemon threads to finish, they may be abruptly terminated when the program exits, even if they haven\u0026rsquo;t completed their work.\nHow we can solve this is by setting the logging thread as daemon thread\nmemoryMonitorThread.setDaemon(true); Memory Usage: 3271760 bytes\rMemory Usage: 4194304 bytes\rMemory Usage: 5255840 bytes\rMemory Usage: 6269928 bytes\rFinished generating random numbers\rProcess finished with exit code 0 Reducing Latency\r1. Latency in Threading:\rIn threading, latency refers to the delay or waiting time between when a thread is scheduled to run and when it actually starts executing, or the time taken to complete a task. This is typically seen as the amount of time it takes for a thread to begin processing or the delay involved in switching between threads.\nExamples in Threading:\rThread Start Latency: The delay between when you create and start a thread and when it actually begins running on a processor. This includes the time to schedule the thread, the overhead of context switching, and any delays introduced by operating system thread management. Context Switch Latency: When the operating system switches the CPU from one thread to another, there is a time delay involved, often known as a \u0026ldquo;context switch\u0026rdquo;. This can impact the overall response time, especially in real-time systems. Task Completion Latency: The time it takes for a thread to complete its work. For example, if a thread performs a computation, latency could refer to how long it takes to finish that task from the time it started. 2. Throughput in Threading:\rIn threading, throughput refers to the amount of work or number of tasks that are completed in a given period of time. It’s a measure of how many operations a set of threads can execute per unit of time. Essentially, it refers to how efficiently multiple threads can process tasks concurrently.\nExamples in Threading:\rTask Throughput: If you have a thread pool, the throughput could refer to how many tasks are processed by the threads in the pool per second. Parallel Throughput: In parallel computing, throughput can be seen as the number of tasks or operations performed by all threads in a multithreaded application in a given period of time. Data Race\rA data race occurs in concurrent programming when two or more threads access the same memory location at the same time, and at least one of the threads modifies the value. The issue arises because the threads are not properly synchronized, leading to unpredictable results or bugs in the program.\n// Thread 1\rx++;\r// Thread 2\rx++; If both threads read the value of x at the same time before either writes back their incremented value, the final value of x might not be what is expected. Both threads may read the same value of x (let\u0026rsquo;s say 5), increment it, and write back 6, even though it should have been 7.\nHow to solve it\rIn some cases, you may want to ensure that a variable’s value is always read from the main memory, and not cached locally in a thread’s cache. This can be useful when dealing with visibility issues (not necessarily data races, but it can still be related).\nclass Counter { private volatile int count; public void increment() { count++; } public int getCount() { return count; } } Or using Synchronization and locks, but this comes later\nclass Counter { private int count = 0; private final Object lock = new Object(); public void increment() { synchronized(lock) { count++; } } public int getCount() { synchronized(lock) { return count; } } } Now we will talk about more topics in multithreading using this youtube video https://www.youtube.com/watch?v=ddUSe3A9MMg.\n","date":"0001-01-01T00:00:00Z","image":"http://localhost:1313/post/java-multithreading/java_hu6082526576852417907.png","permalink":"http://localhost:1313/post/java-multithreading/","title":"Java Multithreading"}]